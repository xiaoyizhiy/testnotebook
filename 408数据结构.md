# 408数据结构

由于数据是存储在连续空间内的，所以每个数据的内存地址(在内存上的位置)都可以通过数组下标算出，我们也就可以借此直接访问目标数据(这叫作“随机访问”)。

排序(Sort)是指重新排列序列中的元素，使之按照关键字递增或递减有序排列。其数学描述为:一个含有n个元素的序列R={R1，R2.….Rn)，对应的关键字序列k=(k1，k2.….kn)，重新排列R中的元素得到序列R={R1‘，R2’..Rn‘)其对应的关键字符合升序或降序。

#### 排序的稳定性

排序算法的稳定性是指在排序过程中，关键字相等的元素的相对次序是否保持不变。如果排序后关键字相等的元素的相对次序仍然和原序列一致，那么这个排序算法就是稳定的;反之，如果相等元素的相对次序发生了变化那么这个排序算法就是不稳定的。

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/ds%20(1).png)

相等的张三和王五是相对次序改变，因此该算法是不稳定的。注意，评价个算法的不难发现，排完序后，成好坏依然是看时间复杂度和空间复杂度，是否稳定只是算法的一个特性。

#### 内部排序和外部排序

内部排序是指在内存中进行的排序。在这种情况下，数据量较小，可以一次性全部读入内存进行排序。外部排序是指数据量较大，无法一次性全部读入内存的情况。因此，需要将数据分成若干个小块，每次读入一部分数据进行排序，最后将排好序的小块合并成一个有序的大块。外部排序通常涉及对外存的访问，因此速度相对较慢。

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/ds%20(2).png)

4.对任意7个关键字进行基于比较的排序，至少要进行( )次关键字之间的两两比较。
A.13
B.14
C.15
D.6

这题为算法导论的结论，408不考。

对于任何基于比较的排序，都可以被抽象为一棵决策树。
例如，若比较序列是由1，2，3三个元素构成（假设不相等），则可以抽象为这样一棵决策树。

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/ds%20(3).png)

这棵决策树把所有可能的比较情况都描述了出来，对于任意长度为n的序列，总共由n!种排序(高中学的全排列)每个叶子结点都描述了一种排列的结果，若设叶子结点的数量为l，则l>=n!不难发现，得到每个排列结果所需要的比较次数其实就是根节点到叶子结点经过的分支结点数目，比较次数不超过树高(不包含叶子结点)，若设决策树的树高为h(不包含叶子结点)，则叶子结点数目不大于2^h，可得n!<=l<=2^h则h>=log2n!
log27!=12.……

#### 直接插入排序

插入排序的基本思想是:每一次将一个待排序元素按照其关键字大小插入进已经排好序的一组元素的适当位置上，直到所有元素都被插入。考研主要考察三种插入排序:直接插入排序、折半插入排序以及希尔排序。

假设待排序序列放在数组a[n]中，总共n个元素进行排序，算法步骤如下：

1. 将数组中的元素分成有序和无序两部分。初始状态下，第一个元素a[0]归为有序部分，其他元素归为无序部分。

2. 依次将无序部分的元素插入到有序部分的合适位置上，具体插入过程如下：

     ​	首先将待插入元素从后往前依次和有序部分的元素进行比较，寻找合适的插入位置p。

     ​	然后将有序部分中位于p以及p之后的有序部分元素全部往后移动一个位置，随后在p处插入待插入元素。

假设我们有一个未排序的数组[8,3,5,4,6]，我们可以使用直接插入排序对其进行排序。

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/ds%20(4).png)

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/ds%20(5).png)

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/ds%20(6).png)

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/ds%20(7).png)

```c
#include<stdio.h>
void insertSort(int a[],int n){
     int i,j,temp;//temp暂存需要插入的元素，因为有序部分要后移
     //第一个元素已经有序，从第二个元素开始插入有序部分
     for(i=1;i<n;i++){
     //若比有序部分的最后一个元素还大，则没必要调整
     //a[i]为要插入的元素，a[i-1]为有序部分的最后一个元素     
          if(a[i]<a[i-1]){
               temp=a[i];//挖个坑，用temp保存被挖出来的a[i-1]
               for(j=i-1;j>=0 && a[j]>temp;j--){//边比较边向后移动
                    a[j+1]=a[j];
			}
          a[j+1]=temp;//这个不需要记，找个例子试一下就能找到temp的位置
          }
      }
}
void printarr(int a[],int n){
     for(int i=0;i<n;i++){
     printf("%d ",a[i]);
     }      
}
int main(){
     int a[5]={8,3,5,4,6};
     printarr(a,5);//将上述数组打印出来
     insertSort(a,5);
     putchar('\n');
     printarr(a,5);
	return 0;
} 
```

###### 算法分析

空间复杂度:直接插入排序仅使用了常数个辅助变量，因此空间复杂度为O(1)。

时间复杂度:最好情况下，表中元素有序，此时每次插入一个元素，都只需要比较一次而不需要移动元素，因此时间复杂度为O(n)。

最坏情况下，表中元素逆序，此时总的比较次数以及移动次数到达最大，时间复杂度为O(n2)。

稳定性:在直接插入排序的过程中，依次将后面无序序列中的元素插入前面的有序序列中，相同的两个元素的相对位置不会发生变化，所以，直接插入排序是稳定的。另外，直接插入排序既适用于顺序存储结构，也适用于链式存储结构，且在链式存储结构上无需移动元素待排序。序列的初始状态会影响比较次数和移动次数，有序和逆序时，算法效率相差较大，在最后一趟排序前，所有元素可能都不在最终位置。

#### 折半插入排序

当待排序的序列存放于顺序表时，可以使用折半查找的方法来寻找插入位置，假设待排序序列放在数组a[n]中，总共n个元素进行排序，算法步骤如下:

1. 将数组中的元素分成有序和无序两部分。初始状态下，第一个元素a[0]归为有序部分，其他元素归为无序部分。

2. 依次将无序部分的元素插入到有序部分的合适位置上，具体插入过程如下:

   ​	首先使用折半查找的方法确定合适的插入位置p。

   ​	然后将有序部分中位于p以及p之后的有序部分元素全部往后移动一个位置，随后在p处插入待插入元素。

假设我们有一个未排序的数组 [8,3,5,4,6]，我们可以使用折半插入排序对其进行排序。

![image-20241127085648337](https://github.com/xiaoyizhiy/testnotebook/blob/main/ds1%20(1).png?raw=true)

mid向下取整

![image-20241127085956385](https://github.com/xiaoyizhiy/testnotebook/blob/main/ds1%20(2).png?raw=true)

```c
#include<stdio.h>
void binaryInsertSort(int a[]],int n){
     int i,j,low,high,mid;
     int temp;//用来暂存待插入元素
//第一个元素已经有序，从第二个元素开始插入有序部分
     for(i=1;i<n;i++){
          tmp=a[i];
          low=0;
          high=i-1;
          while(low<=high){
               mid=(low+high)/2;
               if(a[mid]>temp){//若中间元素比temp大，则插入左半表
                    high=mid-1;
               }else{
                    low=mid+1;//否则插入右半表
               }
          }
		for(j=i-1;j>=low;--j){//low为目标插入位置
               a[j+1]=a[j];//将插入位置及其后面的元素都往后移动
          }
		a[low]=temp;
     }
}
void printarr(int a[]],int n){
     for(int i=0;i<n;i++){
          printf("%d ",a[i]);
     }
}
int main(){
	int a[5]={8,3,5,4,6};
     printarr(a,5);
     binarylnsertSort(a,5);
     putchar('\n');
	printarr(a,5);
     return 0;
}
```

###### 算法分析

空间复杂度:与直接插入排序相同，空间复杂度为0(1)。

时间复杂度，相比于直接插入排序，折半插入排序所需要的关键字比较次数与待排序序列的初始排列无关，仅依赖于元素个数。设当前有序序列记录的个数为i，每一趟确定插入位置的比较次数约为log2(i+1)，一共n-1趟，总比较次数约为O(nlog2n)。
折半查找的移动次数与直接插入排序相同，时间复杂度由比较次数以及移动次数中的最高阶决定，最坏情况为O(n2)，最好情况为O(nlog2n)，平均复杂度为O(n2)

稳定性:折半插入排序仅有查找插入位置的方式与直接插入排序不同，因此也是稳定的。另外，折半插入排序只适用于顺序存储结构，待排序序列的初始状态不会影响比较次数，但影响移动次数。在最后一趟排序前，所有元素可能都不在最终位置。


#### 希尔排序

不难发现，在直接插入排序中，若待排序的记录个数较少且关键字基本有序时，其效率提升较为明显。希尔排序根据以上发现，基于直接插入排序改进而生。

希尔排序的实质是分组插入排序，也称为递减增量排序算法。

​	首先，将整个待排元素序列分割成若干个子序列，每个子序列由相隔某个“增量”的元素组成;

​	接着对每个子序列分别进行直接插入排序;然后依次缩减增量再进行排序，直到整个序列中的元素基本有序(增量足够小)，最后对全体元素进行一次直接插入排序。

算法步骤如下:

1. 第一趟选取增量d1(d1<n)，把全部记录分成d1个小组,每个小组内的记录为arr[i]，arr[i+d1]，arr[i+2d1]，arr[i+3d1],arr[i+4d1]..arr[i+kd1]，(0<=i>=d1)，然后分别对每一组内的记录做直接插入排序，
2. 继续选择增量d2(d2<d1)，重复步骤1中等分组和排序。
3. 不断重复步骤2，直至增量di=1，即在最后一趟对所有记录进行依次直接插入排序。

增量序列的选取对希尔排序的算法效率影响较大，目前尚未产生最佳增量序列。

我们以数组[48，39，64，93，76，15，27，48，56，03]作为示例。

![image-20241127092806963](https://github.com/xiaoyizhiy/testnotebook/blob/main/ds1%20(3).png?raw=true)

![image-20241127093122590](https://github.com/xiaoyizhiy/testnotebook/blob/main/ds1%20(4).png?raw=true)

代码考察的可能性低。

###### 算法分析

稳定性：希尔排序是不稳定的（希尔排序由于分组和跨组交换，无法保证不改变顺序，因此它是不稳定的）。另外，希尔排序只适用于顺序存储结构。当数据量较大时，希尔排序明显优于直接插入排序。当采用一个较好的增量序列且数据量较少时，使用希尔排序会比快排和堆排更快，但在涉及大量数据时，希尔排序比快排慢。在最后一趟排序前，所有元素可能都不在最终位置。

#### 冒泡排序（交换排序）

交换排序是一类排序算法的总称，它们的工作原理是通过交换相邻的元素来对序列进行排序。这类算法中最著名的代表是冒泡排序(Bubble Sort)和快速排序(Quick Sort)。

冒泡排序的基本思想是，从后往前(或从前往后)两两比较相邻元素的位置，若为逆序(A[i-1]>A[i])则交换它们，直到序列比较完。算法步骤如下:

1. 从数组的第一个元素开始，比较相邻的两个元素。
2. 如果当前元素比后一个元素大，就交换它们的位置。这样，每一轮比较后，最大的元素会被“冒泡”到它应该在的位置，即当前遍历的最右边。
3. 继续向后移动，对下一对相邻元素执行相同的比较和交换操作，直到到达数组的末尾。
4. 重复上述过程，每次遍历后，最大的未排序元素会被放)在它应该在的位置。随着遍历的进行，不需要再检查已经排序好的元素，因此每次遍历的长度会逐渐减少。
5. 当进行完一次完整的遍历而没有发生任何交换时，说明数组已经完全排序，算法结束。

假设我们有一个未排序的数组[8,3,5,4,6]，我们可以使用直接插入排序对其进行排序。

![image-20241127162852446](https://github.com/xiaoyizhiy/testnotebook/blob/main/ds1%20(5).png?raw=true)

![image-20241127164356339](https://github.com/xiaoyizhiy/testnotebook/blob/main/ds1%20(6).png?raw=true)

```c
//冒泡排序
#include<stdio.h>
void bubbleSort(int a[],int n){
	int temp;//交换时作为临时变量
     int flag;//交换标志
	for(int i=0:i<n-1:i++){
		flag=0;//每趟比较前先将标志置否
		for(int j=0;j<n-i-1;j++){
			if(a[j]>a[j+1]){//逆序，则交换
              		flag=1;//发生交换，则flag置为1
				temp=a[j];
				a[j]=a[j+1];
				a[j+1]=temp;//交换操作
               }
          }
		if(flag==0){
               return;//未发生交换，则排序提前结束
          }
     }
}
void printarr(int a[],int n){
     for(int i=0;i<n;i++){
          printf("%d",a[i]);
     }
}
int main(){
     int a[5]={8,3,5,4,6};
	printarr(a,5);
	bubbleSort(a,5);
	putchar('\n');
	printarr(a,5);
	return 0;
}
```

###### 算法分析

空间复杂度：冒泡排序仅使用了常数个辅助变量，因此空间复杂度为O(1)。

时间复杂度：最好情况下，表中元素有序，需要一趟冒泡排序过程，比较次数为n-1次，没有交换操作，因此时间复杂度为O(n)。

![image-20241128173629629](https://github.com/xiaoyizhiy/testnotebook/blob/main/ds1%20(7).png?raw=true)

最坏情况下，表中元素逆序，第一趟冒泡需要比较n-1次，第二趟需要n-2次，每趟比较次数递减，总比较次数为n(n-1)/2，总移动次数为总比较次数的三倍，时间复杂度为二者之和，为O(n2)。

![image-20241128173637269](https://github.com/xiaoyizhiy/testnotebook/blob/main/ds1%20(8).png?raw=true)

稳定性:在冒泡排序的过程中，总是从前往后(或从后往前)进行，关键字(元素)相等时不会交换，且每次交换都是相邻元素交换，是一种稳定的算法。另外，冒泡排序既适用于顺序存储结构，也适用于链式存储结构，待排序序列的初始状态会影响排序趟数、比较次数和移动次数，平均性能比直接插入排序要差，每趟排序都会将一个元素放到最终位置上。

#### 快排（交换排序）

快排是对冒泡排序的一种改进方法，总体效率较高，算法步骤如下:

1. 选择枢轴(Pivot):从数组中选择一个元素作为枢轴，选择方法有多种，如选择第个元素、最后一个元素、中间元素或随机选择一个元素。
2. 划分(Partition):重新排列数组(可以通过挖坑法实现)，所有比枢轴小的元素放在枢轴的前面，所有比枢轴大的元素放在枢轴的后面(和枢轴相等的数可以到任一边)。此次划分结束之后，枢轴所在的位置就是其最终位置。（至少一个）
3. 递归排序:递归地将枢轴元素的左子表和右子表进行快速排序。

假设我们有一个未排序的数组 [63，37，48，95，75，14，28，48]，我们可以使用快排对其进行排序。

挖坑法的基本步骤如下:

1. 挖掉枢轴元素，这里选择第一个元素作为枢轴元素，即挖掉a[low]。
2. 从high指向的位置不断向前査找，直至找到一个比pivotkey小的元素，挖掉a[high]的元素，填入a[low]的坑中，随后执行low++。
3. 从low指向的位置不断向后查找，直至找到一个比pivotkey大的元素，挖掉a[low]的的元素，填入a[high]的坑中，随后执行high++。
4. 不断重复2、3过程，直至high==low，将pivotkey填入a[low]中

![image-20241128204028233](https://github.com/xiaoyizhiy/testnotebook/blob/main/ds1%20(9).png?raw=true)

![image-20241128204039604](https://github.com/xiaoyizhiy/testnotebook/blob/main/ds1%20(10).png?raw=true)

![image-20241128204056320](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241128204056320.png)

![image-20241128204119313](https://github.com/xiaoyizhiy/testnotebook/blob/main/ds1%20(12).png?raw=true)



![image-20241128204133560](https://github.com/xiaoyizhiy/testnotebook/blob/main/ds1%20(13).png?raw=true)

![image-20241128204133560](https://github.com/xiaoyizhiy/testnotebook/blob/main/ds1%20(14).png?raw=true)

![image-20241128204148490](https://github.com/xiaoyizhiy/testnotebook/blob/main/ds1%20(15).png?raw=true)

不难发现，和折半查找判定树，BST都有点像捏，另外，每一趟排序完，至少一个元素的的最终位置被确定。若枢轴元素划分出的两个子表不为空，则下一趟排序后，有两个元素的最终位置被确定;若枢轴元素划分出的一个子表为空，则下一趟排序后，仅有一个元素的最终位置被确定。

```c
#include<stdio.h>
int Partition(int a[],int low,int high){
     int pivotkey=a[low];
     while(low<high){
     //从右往左找到一个比pivotkey小的关键字
     	while(low<high&&a[high]>=pivotkey){
          high--;
          }
		a[low]=a[high];
     	//从左往右找到一个比pivotkey大的关键字
     	while(low<high&&a[low]<=pivotkey){
          	low++;
          }
		a[high]=a[low];
     }
	a[low]=pivotkey;
	return low;
}
void QuickSort(int a[],int low,int high){
     if(low<high){
          int pivot=Partition(a,low,high);//对序列进行划分			
          QuickSort(a,low,pivot-1);//递归划分左子表
          QuickSort(a,pivot+1,high);//递归划分右子表
     }
}
void printarr(int a[],int n){
     for(int i=0;i<n;i++){
          printf("%d ",a[i]);
     }
}
int main(){
     int a[5]={8,3,5,4,6};
     printarr(a,5);
     QuickSort(a,0,4);
     putchar('\n');
     printarr(a,5);
     return 0;
}
```

###### 算法分析

空间复杂度:快排是递归的，因此需要一个递归栈来实现递归，递归栈的深度等于递归树的高度,最好的情况下，即快排的每一趟都将元素均匀地分割成长度相近的两个子表，空间复杂度为O(log2n)。最坏的情况下，快排的每一趟的划分都有一个子表是空表，空间复杂度为O(n)。

时间复杂度:快排的一次划分算法从两头交替搜索，直到ow和high重合，因此时间复杂度是0(n)，整个快排的时间复杂度与划分的趟数有关。
最好的情况是每次所选的枢轴能将序列划分成两个长度近似相等的子表，此时快排递归树的高度最小，即排序所需要的趟数最小，此时树的高度为[log2(n+1)]，整个快排的时间复杂度为O(nlog2")。最坏的情况是每次选择的枢轴是当前序列中的最大(最小)元素，划分所得的子表中，一个为空表，另一子表的长度为原表长度-1，此时快排递归树会长成一棵单支树，树的高度为n，时间复杂度为0(n?)因此，枢轴的选择决定了快排的时间复杂度，可以通过一些方法选择更合适的枢轴元素。例如，可以选择第一个关键字，中间一个关键字以及最后一个关键字中的中位数作为枢轴。快排的平均时间复杂度为0(nlog2")，是所有内部排序算法中平均性能最优的排序算法。稳定性:例如(4，3，3}，可以看出快排是不稳定的。另外，每趟排序后都会将上一趟划分的各个无序子表的枢轴元素放到其最终位置上。

#### 字符串

###### BF算法

BF算法，又叫做暴力模式匹配或简单模式匹配算法，采用穷举的思路(穷举就是指把所有可能发生的情况列出来)解决字符串模式匹配。

![image-20250111140221121](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20250111140221121.png)

![image-20250111140232401](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20250111140232401.png)

![image-20250111140245921](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20250111140245921.png)

 ###### 算法分析

算法的时间复杂度为O(n*m)，其中n和m分别是主串和模式串的长度。

###### KMP算法

最长公共前后缀

前缀指字符串中包含第一位字符，且不包含最后一位字符的子串。
后缀指字符串中包含最后一位字符，且不包含第一位字符的子串。

![image-20250111140833364](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20250111140833364.png)

方法：

同时找到长度相等的前缀与后缀，并查看是否相等，直至找到所有的前后缀。

![image-20250111141022734](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20250111141022734.png)

next数组

![image-20250111142007936](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20250111142007936.png)

初始时，next[1]==0，其他next值为空

next[2]==2号字符前的字符串（a）的最长公共前后缀（不存在，为空）的后一个位置，即next[2]==1。

next[3]==3号字符前的字符串（ab）的最长公共前后缀（不存在，为空）的后一个位置，即next[3]==1。

next[4]==4号字符前的字符串（abc）的最长公共前后缀（不存在，为空）的后一个位置，即next[4]==1。

next[5]==5号字符前的字符串（abca）的最长公共前后缀（a）的后一个位置，即next[5]==2。

###### KMP匹配

![image-20250111142025134](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20250111142025134.png)

![image-20250111142042599](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20250111142042599.png)                                

![image-20250111142058851](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20250111142058851.png)

![image-20250111142118777](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20250111142118777.png)

>next数组的编号可以从0开始，初始时next[0]=-1。

###### 算法分析

普通模式匹配的时间复杂度是O(mn)，KMP算法的时间复杂度是O(m+n)，但在一般情况下，普通模式匹配的实际执行时间近似为O(m+n)，因此仍被采用。KMP算法仅在主串与子串有很多“部分匹配”时才显得比普通算法快得多，其主要优点是主串不回溯。

###### nextval

next数组在某些情况下尚有缺陷，还可以进一步优化。例如模式串S='aaaab'和主串'aaabaaaab'进行匹配时:

![image-20250111143024994](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20250111143024994.png)

![image-20250111143258535](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20250111143258535.png)

![image-20250111143309886](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20250111143309886.png)

![image-20250111143355090](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20250111143355090.png)

###### KMP的原理

跳过

#### 树

树是n(n>=0)个结点的有限集合，n=0时，称为空树，这是一种特殊情况。在任意一棵非空树中应满足:

1)有且仅有一个特定的称为根的结点

2)当n>1时，其余结点可分为m(m>0）个互不相交的有限集合T1,T2，.…, Tm，其中每个集合本身又是一棵树，并且称为根结点的子树。

![image-20250113110514659](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20250113110514659.png)

 互不相交指的是除根结点外每个结点只有一个前驱。如图，D有两个前驱。

![image-20250113110541374](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20250113110541374.png)

![image-20250113110722649](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20250113110722649.png)

树是一种递归定义的数据结构。

###### 树形逻辑结构的应用

![image-20250113110814435](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20250113110814435.png)

![image-20250113110822936](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20250113110822936.png)

###### 结点之间的关系描述

![image-20250113111138098](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20250113111138098.png)

什么是祖先结点?
什么是子孙结点?
什么是双亲结点(父节点)?
什么是孩子结点?
什么是兄弟结点?
什么是堂兄弟结点? （理解为同一层的结点即可）

什么是两个结点之间的路径? （路径是有方向的，只能从上往下）如：F到G不存在路径。
什么是路径长度? （经过几条边）

###### 结点、树的属性描述

结点的度--有几个孩子(分支)

树的度--各结点的度的最大值

![image-20250113111926346](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20250113111926346.png)

###### 有序树 Vs 无序树

有序树--逻辑上看，树中结点的各子树从左至右是有次序的，不能互换。

无序树--逻辑上看，树中结点的各子树从左至右是无次序的，可以互换。

具体看你用树存什么，是否需要用结点的左右位置反映某些逻辑关系。

###### 树 VS 森林


森林是m(m>=0)棵互不相交的树的集合。eg:全中国所有人家的家谱

![image-20250113112912306](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20250113112912306.png)

![image-20250113113030871](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20250113113030871.png)

###### 树的常考性质

常见考点1:结点数=总度数+1
结点的度--结点有几个孩子(分支)

常见考点2:度为m的树、m叉树 的区别

- 树的度--各结点的度的最大值 
- m叉树--每个结点最多只能有m个孩子的树

![image-20250113114118065](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20250113114118065.png)

![image-20250113114142649](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20250113114142649.png)

常见考点3:度为m的树第i层至多有m^(i-1) 个结点(i>=1)
m又树第i层至多有m^(i-1) 个结点(i>=1)

![image-20250113114436631](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20250113114436631.png)

![image-20250113114641008](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20250113114641008.png)

常见考点5:高度为h的m又树至少有h个结点。
高度为h、度为m的树至少有 h+m-1 个结点。

![image-20250113114833017](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20250113114833017.png)

![image-20250113115045343](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20250113115045343.png)

![image-20250113115138532](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20250113115138532.png)
