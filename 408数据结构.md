# 408数据结构

排序(Sort)是指重新排列序列中的元素，使之按照关键字递增或递减有序排列。其数学描述为:一个含有n个元素的序列R={R1，R2.….Rn)，对应的关键字序列k=(k1，k2.….kn)，重新排列R中的元素得到序列R={R1‘，R2’..Rn‘)其对应的关键字符合升序或降序。

#### 排序的稳定性

排序算法的稳定性是指在排序过程中，关键字相等的元素的相对次序是否保持不变。如果排序后关键字相等的元素的相对次序仍然和原序列一致，那么这个排序算法就是稳定的;反之，如果相等元素的相对次序发生了变化那么这个排序算法就是不稳定的。

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/ds%20(1).png)

相等的张三和王五是相对次序改变，因此该算法是不稳定的。注意，评价个算法的不难发现，排完序后，成好坏依然是看时间复杂度和空间复杂度，是否稳定只是算法的一个特性。

#### 内部排序和外部排序

内部排序是指在内存中进行的排序。在这种情况下，数据量较小，可以一次性全部读入内存进行排序。外部排序是指数据量较大，无法一次性全部读入内存的情况。因此，需要将数据分成若干个小块，每次读入一部分数据进行排序，最后将排好序的小块合并成一个有序的大块。外部排序通常涉及对外存的访问，因此速度相对较慢。

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/ds%20(2).png)

4.对任意7个关键字进行基于比较的排序，至少要进行( )次关键字之间的两两比较。
A.13
B.14
C.15
D.6

这题为算法导论的结论，408不考。

对于任何基于比较的排序，都可以被抽象为一棵决策树。
例如，若比较序列是由1，2，3三个元素构成（假设不相等），则可以抽象为这样一棵决策树。

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/ds%20(3).png)

这棵决策树把所有可能的比较情况都描述了出来，对于任意长度为n的序列，总共由n!种排序(高中学的全排列)每个叶子结点都描述了一种排列的结果，若设叶子结点的数量为l，则l>=n!不难发现，得到每个排列结果所需要的比较次数其实就是根节点到叶子结点经过的分支结点数目，比较次数不超过树高(不包含叶子结点)，若设决策树的树高为h(不包含叶子结点)，则叶子结点数目不大于2^h，可得n!<=l<=2^h则h>=log2n!
log27!=12.……

#### 直接插入排序

插入排序的基本思想是:每一次将一个待排序元素按照其关键字大小插入进已经排好序的一组元素的适当位置上，直到所有元素都被插入。考研主要考察三种插入排序:直接插入排序、折半插入排序以及希尔排序。

假设待排序序列放在数组a[n]中，总共n个元素进行排序，算法步骤如下：

1. 将数组中的元素分成有序和无序两部分。初始状态下，第一个元素a[0]归为有序部分，其他元素归为无序部分。

2. 依次将无序部分的元素插入到有序部分的合适位置上，具体插入过程如下：

     ​	首先将待插入元素从后往前依次和有序部分的元素进行比较，寻找合适的插入位置p。

     ​	然后将有序部分中位于p以及p之后的有序部分元素全部往后移动一个位置，随后在p处插入待插入元素。

假设我们有一个未排序的数组[8,3,5,4,6]，我们可以使用直接插入排序对其进行排序。

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/ds%20(4).png)

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/ds%20(5).png)

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/ds%20(6).png)

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/ds%20(7).png)

```c
#include<stdio.h>
void insertSort(int a[],int n){
     int i,j,temp;//temp暂存需要插入的元素，因为有序部分要后移
     //第一个元素已经有序，从第二个元素开始插入有序部分
     for(i=1;i<n;i++){
     //若比有序部分的最后一个元素还大，则没必要调整
     //a[i]为要插入的元素，a[i-1]为有序部分的最后一个元素     
          if(a[i]<a[i-1]){
               temp=a[i];//挖个坑，用temp保存被挖出来的a[i-1]
               for(j=i-1;j>=0 && a[j]>temp;j--){//边比较边向后移动
                    a[j+1]=a[j];
			}
          a[j+1]=temp;//这个不需要记，找个例子试一下就能找到temp的位置
          }
      }
}
void printarr(int a[],int n){
     for(int i=0;i<n;i++){
     printf("%d ",a[i]);
     }      
}
int main(){
     int a[5]={8,3,5,4,6};
     printarr(a,5);//将上述数组打印出来
     insertSort(a,5);
     putchar('\n');
     printarr(a,5);
	return 0;
} 
```

