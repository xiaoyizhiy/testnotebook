# 408 计算机网络 #

internet:互联网（互连网），通用名词，任意通信协议

Internet:因特网，专用名词，TCP/IP协议族

因特网发展的三个阶段：

| 1969                                                      | 1985                                   | 1993                                     |
| --------------------------------------------------------- | -------------------------------------- | ---------------------------------------- |
| ARPANET向互连网发展                                       | 三级结构因特网                         | 多层次ISP结构的因特网                    |
| 1969年，第一个分组交换网ARPANET                           | 1985年，NSFNET(主干网、地区网和校园网) | 1993年，NSFNET被替代，由各种ISP运营      |
| 70年代中期，研究多种网络的互连                            | 1990年，ARPANET任务完成，正式关闭      | 1994年，WWW技术推动因特网迅速发展        |
| 1983年，TCP/IP协议成为ARPANET的标准协议（因特网诞生时间） | 1991年，因特网初步商业化，开始收费     | 1995年，NSFNET停止运作，因特网彻底商业化 |

ISP：Internet Service Provider, 中国为电信、移动、联通，各用户通过ISP接入因特网。

因特网的标准化工作
因特网的标准化工作是面向公众的，其任何一个建议标准在成为因特网标准之前都以RFC技术文档的形式在因特网上发表。
RFC(Request For Comments)的意思是“请求评论”。任何人都可以从因特网上免费下载RFC文档(http:www.ietf.org/rfc.html)，并随时对某个RFC文档发表意见和建议。

电路交换：

报文交换：

分组交换：

| 电路交换                                                     | 报文交换                                                     | 分组交换                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ | :----------------------------------------------------------- |
| （1）建立连接：分配通信资源 <br/>（2） 通话：一直占用通信资源<br/>（3）释放连接：归还通信资源。 |                                                              | 报文交换是分组交换的前身。<br/>在报文交换中，报文被整个地发送，而不是拆分成若干个分组进行发送。交换节点将报文整体接收完成后才能查找转发表，将整个报文转发到下一个节点。 |
|                                                              | 没有建立连接和释放连接的过程。<br/>分组传输过程中逐段占用通信链路有较高的通信线路利用率。<br/>交换节点可以为每一个分组独立选择转发路由，使得网络有很好的生存性 |                                                              |
| 计算机之间的数据传送是突发式的，当使用电路交换来传送计算机数据时，其线路的传输效率一般都会很低，线路上真正用来传送数据的时间往往不到10%甚至1%。 | 分组首部带来了额外的传输开销。<br/>交换节点存储转发分组会造成一定的时延。<br/>无法确保通信时端到端通信资源全部可用，在通信量较大时可能造成网络拥塞。分组可能会出现失序和丢失等问题。 | 报文交换比分组交换带来的转发时延要长很多需要交换节点具有的缓存空间也大很多 |

三种交换方式的对比
若要连续传送大量的数据，并且数据传送时间远大于建立连接的时间，则使用电路交换可以有较高的传输效率。然而计算机的数据传送往往是突发式的，采用电路交换时通信线路的利用率会很低。<br/>报文交换和分组交换都不需要建立连接(即预先分配通信资源)，在传送计算机的突发数据时可以提高通信线路的利用率。<br/>
将报文构造成若干个更小的分组进行分组交换，比将整个报文进行报文交换的时延要小，并且还可以避免太长的报文长时间占用链路，有利于差错控制，同时具有更好的灵活性。


计算机网络早期的一个最简单定义：互连、自治（每台计算机都有独立的软件和硬件，并且可以单独运行）、计算机集合。

计算机网络的分类

| 交换方式                     | 使用者                                           | 传输介质           | 覆盖范围                                                     | 拓扑结构                     |
| ---------------------------- | ------------------------------------------------ | ------------------ | ------------------------------------------------------------ | ---------------------------- |
| 电路交换、报文交换、分组交换 | 公用网（因特网）、专用网(军队、铁路、电力、银行) | 有线网络、无线网络 | 广域网(WAN)几十到几干干米、城域网(MAN)5到50干米、局域网(LAN)1千米左右、个域网(PAN)10米 | 总线型、星型、环型、网状型。 |



***



***



计算机网络的性能指标：
计算机网络的性能指标被用来从不同方面度量计算机网络的性能。

常用的八个计算机网络性能指标

| 速率                                                         | 带宽                                                         | 吞吐量                                                       | 时延                                                         | 时延带宽积                                                   | 往返时间                                                     | 利用率 | 丢包率                                                       |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------ | ------------------------------------------------------------ |
| 数据的传送速率(即每秒传送多少个比特) 可简记为b/s，也称为数据率、比特率 | 用来表示网络的通信线路所能传送数据的能力，即在单位时间内从网络中的某一点到另一点所能通过的最高速率。<br/>数据传送速率=min[主机接口速率，线路带宽，交换机或路由器的接口速率] | 吞吐量是指在单位时间内通过某个网络或接口的实际数据量。吞吐量常被用于对实际网络的测量以便获知到底有多少数据量通过了网络。<br/>吞吐量受网络带宽的限制。 | 时延是指数据从网络的一端传送到另一端所耗费的时间，也称为延迟或迟延。数据可由一个或多个分组、甚至是一个比特构成。 | 时延带宽积是传播时延和带宽的乘积。<br/>链路的时延带宽积也称为以比特为单位的链路长度，这对我们以后理解以太网的最短帧长是非常有帮助的。 | 往返时间(Round-Trip Time，RTT)是指从发送端发送数据分组开始，到发送端收到接收端发来的相应确认分组为止，总共耗费的时间。 |        | 丢包率是指在一定的时间范围内，传输过程中丢失的分组数量与总分组数量的比率 |
|                                                              |                                                              |                                                              |                                                              |                                                              |                                                              |        |                                                              |

| 速率的单位      | 换算关系                            | 数据量的单位 | 换算关系                  |
| --------------- | ----------------------------------- | ------------ | ------------------------- |
| 比特/秒(b/s)    | 基本单位                            | 比特(b)      | 基本单位                  |
|                 |                                     | 字节(B)      | 1B = 8bit                 |
| 千比特/秒(kb/s) | kb/s =10<sup>3</sup> b/s            | 干字节(KB)   | KB=2<sup>10</sup>B        |
| 兆比特/秒(Mbs)  | Mb/s = k*kb/s = 10<sup>6</sup> b/s  | 兆字节(MB)   | MB =K*KB=2<sup>20</sup>B  |
| 吉比特/秒(Gb/s) | Gb/s= k*Mb/s = 10<sup>9</sup> b/s   | 吉字节(GB)   | GB=K*MB = 2<sup>30</sup>B |
| 太比特/秒(Tb/s) | Tb/s = k*Gb/s = 10<sup>12</sup> b/s | 太字节(TB)   | TB=K*GB=2<sup>40</sup>B   |

```plaintext
发送时延只涉及数据从发送端推送到网络所需的时间，不包括数据在网络中的传播时延、处理时延或排队时延。
对于高带宽网络，发送时延通常较短，但当数据量较大时，发送时延会显著增加。
发送时延=分组长度(b)/发送速率（b/s）=数据大小/带宽
```

```plaintext
传播时延=信号长度(m)/信号传播速率（m/s）
```

排队时延和处理时延不方便计算

```plaintext
发送速率=min[主机接口速率，线路带宽，交换机或路由器的接口速率]
```

| 链路利用率                                                   | 网络利用率                                           |
| ------------------------------------------------------------ | ---------------------------------------------------- |
| 链路利用率是指某条链路有百分之几的时间是被利用的(即有数据通过)<br/>完全空闲的链路的利用率为零 | 网络利用率是指网络中所有链路的链路利用率的加权平均。 |

根据排队论可知，当某链路的利用率增大时，该链路引起的时延就会迅速增加。

当网络的通信量较少时，产生的时延并不大，但在网络通信量不断增大时，分组在交换节点(路由器或交换机)中的排队时延会随之增大，因此网络引起的时延就会增大。

令D<sub>0</sub>表示网络空闲时的时延，D表示网络当前的时延，那么在理想的假定条件下，可用下式来表示D、D<sub>0</sub>和网络利用率U之间的关系。

```plaintext
D(网络当前时延) = D0(网络空闲时的时延) / (1 - U)
```

分组丢失主要有以下两种情况:

1. 分组在传输过程中出现误码，被传输路径中的节点交换机(例如路由器)或目的主机检测出误码而丢弃。
2. 节点交换机根据丢弃策略主动丢弃分组.

丢包率可以反映网络的拥塞情况:

1. 无拥塞时路径丢包率为0。
2. 轻度拥塞时路径丢包率为1%~4%。
3. 严重拥塞时路径丢包率为5%~15%。


常见的三种计算机网络体系解构：

1. | OSI                                                          | TCP/IP     | 1    |
   | ------------------------------------------------------------ | ---------- | ---- |
   | 应用层                                                       | 应用层     |      |
   | 表示层                                                       | 运输层     |      |
   | 会话层                                                       | 网际层     |      |
   | 运输层                                                       | 网络接口层 |      |
   | 网络层                                                       |            |      |
   | 数据链路层                                                   |            |      |
   | 物理层                                                       |            |      |
   | OSI标准失败的原因<br/>专家没有实际经验完成标准时没有商业驱动力<br/>协议实现过分复杂运行效率很低<br/>标准的制定周期太长产品无法及时进入市场<br/>层次划分不太合理有些功能在多个层次中重复出现 |            |      |

误码的相关概念
实际的通信链路都不是理想的，比特在传输过程中可能会产生差错(称为比特差错)
比特1可能变成比特0
比特0可能变成比特1
在一段时间内，传输错误的比特数量占所传输比特总数的比率称为误码率(Bit Error Rate，BER)提高链路的信噪比，可以降低误码率。但在实际的通信链路上，不可能使误码率下降为零。

使用差错检测技术来检测数据在传输过程中是否产生了比特差错，是数据链路层所要解决的重要问题之一。

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%91%20(1).png)

检错码成为FCS

奇校验是在待发送的数据后面添加1个校验位，使得添加该校验位后的整个数据中比特1的个数为奇数。
偶校验是在待发送的数据后面添加1个校验位，使得添加该校验位后的整个数据中比特1的个数为偶数。

在所传输的数据中，如果有奇数个位发生误码，则所包含比特1的数量的奇偶性会发生改变，可以检测出误码。
在所传输的数据中，如果有偶数个位发生误码，则所包含比特1的数量的奇偶性不会发生改变，无法检测出误码(漏检)
在实际使用时，奇偶校验又可分为垂直奇偶校验、水平奇偶校验以及水平垂直奇偶校验。

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%91%20(2).png)

循环冗余校验
数据链路层广泛使用漏检率极低的循环冗余校验:(Cyclic Redundancy Check，CRC)检错技术
循环冗余校验CRC的基本思想:
**收发双方约定好一个生成多项式G(X)。**

**发送方基于待发送的数据和生成多项式G(X)，计算出差错检测码(冗余码)**

**将冗余码添加到待发送数据的后面一起传输。**

**接收方收到数据和冗余码后，通过生成多项式G(X)来计算收到的数据和冗余码是否产生了误码。**

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%91%20(3).png)

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%91%20(4).png)

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%91%20(5).png)

算法要求生成多项式必须包含最低次项即x的0次项 。

**发送方的处理：**

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%91%20(6).png)

生成多项式为G(X)=1乘以X^3+1乘以X^2+0乘以X^1+1乘以X^0

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%91%20(7).png)

1为够除即被除数和除数位数相同都为4位。

最后一行的1位余数。

**接收方的处理**

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%91%20(8).png)

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%91%20(9).png)

写错了，接收方构建被除数时不要将生成多项式的系数添加到后面。

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%91%20(10).png)

>奇偶校验、循环冗余校验等差错检测技术，只能检测出传输过程中出现了差错，但并不能定位错误因此无法纠正错误。
>
>要想纠正传输中的差错，可以使用冗余信息更多的纠错码(例如海明码)进行前向纠错。但纠错码的开销比较大，在计算机网络中较少使用。
>
>在计算机网络中，通常采用我们后续课程中将要介绍的检错重传方式来纠正传输中的差错，或者仅仅丢弃检测到差错的帧，这取决于数据链路层向其上层提供的是可靠传输服务还是不可靠传输服务。
>
>循环冗余校验CRC具有很好的检错能力(漏检率极低)，虽然计算比较复杂，但非常易于用硬件实现因此被广泛应用于数据链路层。



#### 可靠传输

使用差错检测技术(例如循环冗余校验CRC)，接收方的数据链路层就可检测出帧在传输过程中是否产生了误码(比特差错)。

检测出误码了怎么做呢？

这取决于数据链路层向其上层提供的服务类型。

若为不可靠传输服务:仅仅丢弃有误码的帧，其他什么也不做，
若为可靠传输服务:通过某种机制实现发送方发送什么，接收方最终就能收到什么。（例如：接收方检测到了误码并向发送方发送一个否认帧，发送方收到否认帧后。重新发送）。

一般情况下，有线链路的误码率比较低。为了减小开销，并不要求数据链路层向其上层提供可靠传输服务。即使出现了误码，可靠传输的问题由其上层处理。

无线链路易受干扰误码率比较高，因此要求数据链路层必须向其上层提供可靠传输服务

传输差错:分组重复、分组失序、分组丢失出现在数据链路层的上层。误码(比特差错)出现在数据链路层及其下层

**误码(比特差错)**
**分组丢失**:当分组到达路由器R2时,由于R2的排队的队列已经满了,现在又来了一个分组,只能将该分组丢弃了.

**分组失序**:主机1发送3个有顺序的分组,这3个分组选择了不同的路径,由于路径长度和路由器的繁忙程度不同,所以先发的分组可能最后到达主机2

**分组重复**:发送的分组到达路由器R5,此时由于R5十分繁忙,导致该分组等待的时间很长,主机1发送超时,所以它重新发送了该分组,该分组选择了一条不繁忙的路径到达了主机2,而在R5的分组也到达了主机2.

可靠传输服务并不局限于数据链路层，其他各层均可选择实现可靠传输。

#### 实现可靠传输的三种协议

停止-等待(Stop-and-Wait，SW)协议、协议回退N帧(Go-back-N，GBN)协议、选择重传(Selective Repeat，SR)协议

这三种可靠传输实现机制的基本原理并不仅限于数据链路层，可以应用到其上各层。

#### 停止-等待(Stop-and-Wait，SW)协议

接收方收不到数据分组，就不会发送相应的ACK（确认分组）或NAK（否认分组）。如果不采取措施，发送方就会一直处于等待接收方ACK或NAK的状态。

为了解决上述问题，发送方可在每发送完一个数据分组时就启动一个超时计时器(Timeout Timer)。

若到了超时计时器所设置的超时重传时间(Retransmission Time-Out，RTO)，但发送方仍未收到接收方的ACK或NAK，就重传之前已发送过的数据分组。

一般可将超时重传时间RTO设置为略大于收发双方的平均往返时间RTT。超过RTO，重传。 

#### 数据分组编号

接收方发送的确认分组丢失，发送方没有收到确认分组，认为发送的数据分组丢失，重新发送数据分组，导致分组重复。

为了避免分组重复这种传输错误，必须给每个分组带上序号。
对于停止-等待协议，由于每发送一个数据分组就停止等待，只要保证每发送一个新的数据分组，其序号与上次发送的数据分组的序号不同就可以了，因此用一个比特来编号就够了，序号有0和1这两个。

接收方接收到了同一数据分组的不同序号时，丢弃该数据分组，并向发送方重新发送一个确认分组。

#### 确认分组编号

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%91%20(11).png)

 发送DATA0，ACK迟到，发送方超时重传DATA0，此时发送方收到了迟到的ACK，发送方发送下一个数据分组DATA1。接收方收到DATA0，根据序号可知，这是一个重复的数据分组，将它丢弃，并发送一个ACK。发送方收到两个对DATA0的ACK，将第二个ACK误认为是对DATA1的。

若对ACK进行比编号，则可知道这是对0号数据分组的重复确认忽略即可。

注意事项：

- 使用超时重传机制后，就可以不使用否认机制了，这样可使协议实现起来更加简单。但是，如果点对点链路的误码率较高，使用否认机制可以使发送方在超时计时器超时前就尽快重传。
- 为了让接收方能够判断所收到的数据分组是否是重复的，需要给数据分组编号。由于停止-等待协议的特性，只需1个比特编序号即可，即序号0和序号1。
- 为了让发送方能够判断所收到的确认分组是否是重复的，需要给确认分组编号，所用比特数量与数据分组所用比特数量一样。
- 数据链路层一般不会出现确认分组迟到的情况，因此在数据链路层实现停止-等待协议可以不用给确认分组编号。
- 给超时计时器设置的超时重传时间RTO应当仔细选择，一般将RTO设置为略大于收发双方的平均往返时间RTT。
- 在数据链路层，点对点的往返时间RTT比较固定，RTO就比较好设定。
- 在运输层，由于端到端往返时间非常不确定，设置合适的超时重传时间RTO有时并不容易。停止-等待协议属于自动请求重传(Automatic Repeat reQuest，ARQ)协议。即重传的请求是发送方自动进行的，而不是接收方请求发送方重传某个误码的数据分组。

#### 停止-等待协议的信道利用率 

TD是发送方发送数据分组所耗费的发送时延（发送方将一个分组完整推送到链路中所需要的时间）。

 TA是接收方发送确认分组所耗费的发送时延。

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%91%20(12).png)

若出现超时重传，对于传送有用的数据信息来说，信道利用率还要降低。
在往返时间RTT相对较大的情况下，为了提高信道利用率，收发双方不适合采用停止-等待协议，而可以选择使用回退N帧(GBN)协议或选择重传(SR)协议。

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%91%20(14).png)

答案为D

#### 回退N帧协议(GBN)

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%91%20(15).png)

采用n个比特给分组编序号，序号范围是0~(2”-1)。本例假设采用3个比特给分组编序号则序号范围是0~7。(3个比特可以表示2^3个分组，若以0开始则为0~7)

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%91%20(16).png)

发送方需要维护一个发送窗口WT，在未收到接收方确认分组的情况下，发送方可将序号落入WT内的所有数据分组连续发送出去。
采用n个比特给分组编序号，则WT的取值范围是1<WT≤(2^n-1)。本例假设采用3个比特给分组编序号，则WT的取值范围是2~7，本例取WT=5。（流水线式发送大于1，不能为8，会导致分组重复）

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%91%20(17).png)

接收方需要维护一个接收窗口WR只有正确到达接收方(无误码)且序号落入WR内的数据分组才被接收方接收。 WR的取值只能是1，这一点与停止-等待协议是相同的。

接收方每正确收到一个序号落入接收窗口的数据分组，就将接收窗口向前滑动一个位置，这样就有一个新的序号落入接收窗口。与此同时，接收方还要给发送方发送针对该数据分组的确认分组。
发送方每收到一个按序确认的确认分组，就将发送窗口向前滑动一个位置，这样就有一个新的序号落入发送窗口，序号落入发送窗口内的数据分组可继续被发送。

在回退N帧协议的工作过程中，发送方的发送窗口和接收方的接收窗口按上述规则不断向前
滑动。因此，这类协议又称为滑动窗口协议。

##### 无传输错误的情况

在无传输差错的情况下，回退N帧协议的信道利用率比停止-等待协议的信道利用率有显著提高。提高的程度取决于发送窗口的大小。

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%91%20(18).png)

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%91%20(19).png)

##### ![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%91%20(20).png)

接收方每正确收到一个序号落入接收窗口的数据分组，就将接收窗口向前滑动一个位置这样就有一个新的序号落入接收窗口。与此同时，接收方还要给发送方发送针对该数据分组的确认分组。

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%91%20(21).png)

发送方每收到一个按序确认的确认分组，就将发送窗口向前滑动一个位置，这样就有一个新的序号落入发送窗口，序号落入发送窗口内的数据分组可继续被发送。

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%91%20(22).png)

##### 超时重传、回退N帧的情况

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%91%20(23).png)

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%91%20(24).png)

通过DATA2中的检错码发现了误码将其丢弃。

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%91%20(25).png)

将DATA2丢弃后接收窗口不再移动

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%91%20(26).png)

3、4的序号未落入窗口（当前接收窗口为2），接收方将其丢弃。

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%91%20(27).png)

若数据分组未落入接收窗口，接收方丢弃该分组，并发送最近的数据分组的确认分组。

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%91%20(28).png)

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%91%20(29).png)

发送方收到0、1的确认分组，就将发送窗口向前滑动两个位置，这样就有新的序号5和6落入发送窗口。

!![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%91%20(30).png)

发送方现在可将5号和6号数据分组发送出去，发送方收到针对1号数据分组的两个重复确认。发送方就知道了2号数据被丢弃，而之后的两个数据分组也被丢弃。

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%91%20(31).png)

 5、6未落入接收窗口，接收方将其丢弃，并发送1的确认分组。

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%91%20(32).png)

我们假设发送方收到四个重复确认时仍然不会立刻重传，当2号数据分组发生超时，发送方就将序号落入发送窗口内的超时的2号数据分组和其后已发送的 3~6号数据分组全部重传，尽管发送方之前已发送的3~6号数据分组到达接收方时并未出现误码，但是接收方只能接收序号落入接收窗口内的数据分组。一旦2号数据分组出现误码被接收方丢弃其后连续发送的3~6号数据分组都要被重传，即一旦出错就需要退回去重传已发送过的N个数据分组。

一个数据分组的差错就可能引起大量数据分组的重传。
在信道质量较差(容易出现误码)的情况下，回退N帧协议的信道利用率并不比停止-等待协议的信道利用率高。

回退N帧协议的接收方采用累积确认方式。

接收方不必对收到的每一个数据分组都发送一个确认分组，而是可以在收到几个序号连续的数据分组后，对按序到达的最后一个数据分组发送确认分组。

接收方何时发送累积确认分组，由具体实现决定。

确认分组ACKn表明序号为n及之前的所有数据分组都已正确接收。

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%91%20(33).png)

发送5个数据分组，返回两个累计确认分组。

若ACK1丢失，发送窗口移动5个。

累积确认的优点
减少向网络中注入确认分组的数量。
即使确认分组丢失，也可能不必重传数据分组。

累积确认的缺点
不能向发送方及时准确地反映出接收方已正确接收的所有数据分组的数量。

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%91%20(34).png)

发送窗口为一次发送的分组的个数，必然大于2。为什么不能为8呢？当发送窗口为8时，接收方接收，发送累计确认分组ACK7，发送途中丢失。发送方超时重传，接收方收到，但是它分辨不了这是重新发的（分组重复，不可靠传输直接丢弃），还是新发的分组（接收窗口后移），所以发送窗口不能为8。

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%91%20(35).png)

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%91%20(36).png)

累计确认分组，说明3之前包括3的数据被接收，发送窗口下滑动4个位置。重传4、5、6、7。

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%91%20(37).png)

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%91%20(38).png)

**没看懂，二轮再学。**

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%912%20(6).png)

#### 选择重传协议(SR)

用n(n>1)个比特给分组编号

1 <WR<=WT （WR超过WT没有意义）

WT+ WR≤ 2^n （确保接收窗口向前滑动后，落入接收窗口内的新序号与之前的旧序号没有重鲁，避免无法分辨新旧数据分组。）

推出1 < WR ≤ 2^(n-1)

当WR取最大值2^(n-1)时，WT能取到的最大值也为 2^(n-1)。

为了使发送方仅重传出现差错的数据分组接收方不再采用累积确认，而需要对每一个正确接收的数据分组进行逐一确认。

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%912%20(1).png)

0出现误码，接收方将其丢弃并接收1~3号数据分组

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%912%20(2).png)

接收方将1~3号缓存后发送对应的确认分组。因为不完整，接收窗口不能不能向前滑动，且数据只能先缓存，不能提交给上层。

发送方接收到确认分组后，记录1~3号已被接收。

到达ATT后，只有0号数据分组的确认分组没有收到，于是超时重传。

重传的0号到达接收方后，接收窗口先后滑动4个位置并发送0号的确认分组，缓存的数据取走。

发送方接收到0号的确认分组后，发送窗口向后移动4个位置，并将缓存中的数据删除。

#### 故意取Wr=5

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%912%20(3).png)

发送方发送0~4的数据分组，接收方收到并滑动窗口，发送对应的确认分组，但是0的确认分组丢失，发送方收到后，记录1~4被接收，0号超时重传，此时，0号的序号落入了接收窗口内，可以被接收，但是接收方错认为了是新的数据被接受，导致了分组重复。

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%912%20(4).png)

与回退N帧协议不同，选择重传协议不采用累积确认，接收方需要对每一个正确接收的数据分组进行逐一确认。
发送方仅重传未收到确认而超时的数据帧，因此重传0号和2号这两个数据帧。

3号帧没有超时，需要先等待，再做后面的处理。

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%912%20(5).png)

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/image-20241125230806859.png)

#### 点对点协议PPP

点对点协议(Point-to-Point Protocol，PPP)是目前使用最广泛的点对点数据链路层协议。
点对点协议PPP是因特网工程任务组(Internet Engineering Task Force，IETF)于1992年制定的。经过多次修订，目前PPP已成为因特网的正式标准[RFC1661，RFC1662]。
点对点协议PPP主要有两种应用:

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%913%20(1).png)

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%913%20(2).png)

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%913%20(3).png)

标志(Flag)字段:PPP帧的定界符，取值为0x7E。

地址(Address)字段:取值为0xFF，预留(目前没有什么作用)
控制(Control)字段:取值为0x03，预留(目前没有什么作用)

协议(Protocol)字段:其值用来指明帧的数据载荷应向上交付给哪个协议处理

帧检验序列(Frame Check Sequence，FCS)字段:其值是使用循环冗余校验CRC计算出的检错码。

##### PPP帧的透明传输

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%913%20(4).png)

标志(Flag)字段:是PPP帧的定界符，取值为:
从字节角度看:取值为0x7E。（字节填充法）
从比特角度看:取值为01111110。（零比特填充法）

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%913%20(5).png)

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%913%20(6).png)

##### PPP帧的差错检测

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%913%20(7).png)

帧检验序列FCS字段:其值是使用循环冗余校验CRC计算出的检错码。

CRC采用的生成多项式为CRC-CCITT=X16+X12+X5+1

接收方每收到一个PPP帧，就进行CRC检验:若CRC检验正确，就收下这个帧;否则，就丢弃这个帧。使用PPP的数据链路层，向上提供的是不可靠数据传输服务。

##### PPP的工作状态

以用户主机拨号接入因特网服务提供者ISP的拨号服务器的过程为例：

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%913%20(8).png)

> 王道117页

PPP链路的开始和结束状态都是静止状态，这时用户pc 与ISP的的拨号服务器之间并不存在物理层的连接。当检测到调制解调器的载波信号，并建立物理层链接后，PPP就进入了链路的建立状态。在建立状态下，链路控制协议LCP，开始协商一些配置选项。若协商成功，就进入鉴别状态，若协商失败，就进入到静止状态。所协商的配置选项包括最大帧长、鉴别协议等。可以不使用鉴别，也可使用口令鉴别协议PAP或挑战握手鉴别协议CHAP。若通信双方无须鉴别或鉴别身份成功，则进入网络状态，若鉴别失败，则进入终止状态。进入网络状态后，PPP链路的两端通过互相交换网络层特定的NCP分组，来进行NCP配置。如果PPP链路的上层使用的是IP协议，则使用IP控制协议IPCP，来对PPP链路的每一端配置IP模块，例如分配IP地址。NCP配置完成后，就进入打开状态，只要链路进入打开状态，双方就可进行数据通信。当出现故障或链路的一端发出终止请求时，就进入终止状态。当载波停止后就回到静止状态。 

#### 共享式以太网

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%913%20(9).png)

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%913%20(10).png)

#### 网络适配器

要将计算机连接到以太网，需要使用相应的网络适配器一般简称为“网卡(Adapter)

在计算机内部，网卡与CPU之间的通信，一般是通过计算机主板上的I/0总线以并行传输方式进行。
网卡与外部以太网(局域网)之间的通信，一般是通过传输媒体(同轴电缆、双绞线电缆、光纤)以串行方式进行的。
网卡除要实现物理层和数据链路层功能，其另外一个重要功能就是要进行并行传输和串行传输的转换，由于网络的传输速率和计算机内部总线上的传输速率并不相同，因此在网卡的核心芯片中都会包含用于缓存数据的存储器。
在确保网卡硬件正确的情况下，为了使网卡正常工作，还必须要在计算机的操作系统中为网卡安装相应的设备驱动程序。驱动程序负责驱动网卡发送和接收帧。

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%914%20(1).png)

#### MAC地址

当多个主机连接在同一个广播信道上，要想实现两个主机之间的通信，则每个主机都必须有一个唯一的标识，即一个数据链路层地址。
在每个主机发送的帧的首部中，都携带有发送主机(源主机)和接收主机(目的主机)的数据链路层地址。由于这类地址是用于媒体接入控制(Medium Access Control，MAC)的，因此被称为MAC地址。

MAC地址一般被固化在网卡的电可擦可编程只读存储器EEPROM中，因此MAC地址也被称为硬件地址，MAC地址有时也被称为物理地址（数据链路层范畴）。

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%914%20(2).png)

一般情况下，普通用户计算机中往往会包含两块网卡:

一块是用于接入有线局域网的以太网卡
另一块是用于接入无线局域网的Wi-Fi网卡

每块网卡都有一个全球唯一的MAC地址，交换机和路由器往往具有更多的网络接口，所以会拥有更多的MAC地址。

综上所述，严格来说，MAC地址是对网络上各接口的唯一标识而不是对网络上各设备的唯一标识。

OUI又称公司标识符。

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%914%20(3).png)

b0~b7为8个比特。

将每4个比特写成一个十六进制的字符，共12个字符，将每两个字符分为一组，中间用短线连接。（MAC地址的标准表示方法）

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%914%20(4).png)

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%914%20(5).png)

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%914%20(6).png)

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%914%20(7).png)

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%914%20(8).png)

主机B发送一个帧，目的地址为广播地址（所有主机均可接收）。

网卡从网络上每收到一个无误码的帧，就检查帧首部中的目的MAC地址，按以下情况处理:

(1)如果目的MAC地址是广播地址(FF-FF-FF-FF-FF-FF)，则接受该帧。

(2)如果目的MAC地址与网卡上固化的全球单播MAC地址相同，则接受该帧。

(3)如果目的MAC地址是网卡支持的多播地址，则接受该帧。

(4)除上述(1)、(2)和(3)情况外，丢弃该帧。

网卡还可被设置为一种特殊的工作方式:工作在混杂方式的网卡混杂方式(Promiscuous Mode)只要收到共享媒体上传来的帧就会收下，而不管帧的目的MAC地址是什么。

对于网络维护和管理人员，这种方式可以监视和分析局域网上的流量，以便找出提高网络性能的具体措施。

嗅探器(Sniffer)就是一种工作在混杂方式的网卡，再配合相应的工具软件(Wire Shark)，就可以作为一种非常有用的网络工具来学习和分析网络。

混杂方式就像一把“双刃剑”，黑客常利用这种方式非法获取网络用户的口令。

全球单播MAC地址就如同身份证上的身份证号码，具有唯一性，它往往与用户个人信息绑定在一起。因此，用户应尽量确保自己拥有的全球单播MAC地址不被泄露。

为了避免用户设备连接Wi-Fi热点时MAC地址泄露的安全问题，目前大多数移动设备都已经采用了随机MAC地址技术。

#### CSMA/CD协议的基本原理

在以太网的发展初期，人们普遍认为“无源的电缆线比有源器件可靠”，因此将多个站点连接在一条总线上来构建共享总线以太网。

共享总线以太网具有天然的广播特性，即使总线上某个站点给另一个站点发送单播帧，表示的信号也会沿着总线传播到总线上的其他各站点。

当某个站点在总线上发送帧时，总线资源会被该站点独占。此时，如果总线上的其他站点也要在总线上发送帧，就会产生信号碰撞。

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%914%20(9).png)

为了解决各站点争用总线的问题，共享总线以太网使用了一种专用协议CSMA/CD，它是载波监听/多址接入/碰撞检测(Carrier Sense Multiple Access Collision Detection)的英文缩写词。

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%914%20(10).png)

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%914%20(11).png)

B发送信号，没有到C，C检测空闲，发送信号，两个信号碰撞。由于碰撞信号里C近，C先检测到，于是停止一段随机时间后，重新载波检测。这是B检测到碰撞信号，于是同理。

发送帧的站点一旦检测到碰撞，除了立即停止发送帧外，还要再继续发送32比特或48比特的人为干扰信号(Jamming Signal)，以便有足够多的碰撞信号使所有站点都能检测出碰撞。

载波监听检测到总线空闲，但总线并不一定空闲，使用CSMA/CD协议的共享总线以太网上的各站点，只是尽量避免碰撞并在出现碰撞时做出退避后重发的处理，但不能完全避免碰撞。

在使用CSMA/CD协议时，由于正在发送帧的站点必须“边发送帧边检测碰撞进行发送和接收，因此站点不可能同时进行全双工通信，而只能进行半双工通信(双向交替通信)。
####  共享式以太网的争用期

使用CSMAVCD协议的共享总线以太网上的任意站点在发送帧的过程中都可能会遭遇碰撞。

某个站点从发送帧开始，最长要经过多长时间，才能检测出自己发送的帧与其他站点发送的帧产生了碰撞?

deta为数据从A到B的传播时延。

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%914%20(12).png)



站点从发送帧开始，最多经过时长2tao(即deta→0)就可检测出所发送的帧是否遭遇了碰撞。

因此，共享总线以太网的端到端往返时间2tao被称为争用期(Contention Period)或碰撞窗口(ColisionWindow)，它是一个非常重要的参数。

站点从发送帧开始，经过争用期2tao这段时间还没有检测到碰撞，就可以肯定这次发送不会产生碰撞。
从争用期的概念可以看出，共享总线以太网上的每一个站点从发送帧开始，到之后的一小段时间内，都有可能遭遇碰撞，而这一小段时间的长短是不确定的，它取决于另一个发送帧的站点与本站点的距离但不会超过总线的端到端往返传播时延，即一个争用期2tao。
很显然，总线的长度越长(单程端到端传播时延越大)，网络中站点数量越多，发生碰撞的概率就越大。
因此，共享以太网的总线长度不能太长，接入的站点数量也不能太多。

10Mb/s共享总线以太网(传统以太网)规定:争用期2tao的值为512比特的发送时间，即51.2微秒。

争用期2tao=512b/10Mb/s=512b/10*10^6b/s=51.2微秒
单程端到端传播时延tao=25.6微秒
假设信号的传播速率为2 x10^8m/s
则总线长度为2x10^8m/s x25.6us=5120m

除考虑了信号传播时延外，还考虑到网络中可能存在转发器所带来的时延以及产生碰撞时继续发送32比特或48比特人为干扰信号所持续的时间等。

共享总线以太网规定:总线长度不能超过2500m。

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%914%20(13).png)

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%914%20(14).png)

最短为deta=tao，最长为deta=0

#### 共享式以太网的最小帧长和最大帧长

为了确保共享总线以太网上的每一个站点在发送完一个完整的帧之前，能够检测出是否产生了碰撞，帧的发送时延就不能少于共享总线以太网端到端的往返时间，即一个争用期2tao。
对于10Mb/s的共享总线以太网，其争用期2tao的值规定为51.2微秒，因此其最小帧长为512b，即64B（比特）。

10Mb/sx51.2us=512b=64B

最小帧长=数据传输速率*争用期2tao

当某个站点在发送帧时如果帧的前64B没有遭遇碰撞，那么帧的后续部分也就不会遭遇碰撞。也就是说，如果遭遇碰撞，就一定是在帧的前64B之内。
由于发送帧的站点边发送帧边检测碰撞，一旦检测到碰撞就立即中止帧的发送，此时已发送的数据量一定小于64B。因此，接收站点收到长度小于64B的帧，就可判定这是一个遭遇了碰撞而异常中止的无效帧，将其丢弃即可。

一般来说，帧的数据载荷的长度应远大于帧首部和尾部的总长度，这样可以提高帧的传输效率。
然而，如果不限制数据载荷的长度上限，就可能使得帧的长度太长，这会带来一些问题。

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%914%20(16).png)

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%914%20(17).png)

 传输时延等于往返时长，最小帧长减少，传输速率不变，传输时延减少，距离减少。



#### 共享式以太网的退避算法

在使用CSMA/CD协议的共享总线以太网中，正在发送帧的站点一边发送帧一边检测碰撞，当检测到碰撞时就立即停止发送，退避一段随机时间后再重新发送。

共享总线以太网中的各站点采用截断二进制指数退避算法来选择退避的随机时间。
(Truncated Binary Exponential Backoff)

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%914%20(18).png)

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%914%20(19).png)

如果连续多次发生碰撞，就表明可能有较多的站点参与竞争信道。但使用上述退避算法可使重传需要推迟的平均时间随重传次数而增大(即动态退避)，因而减小产生碰撞的概率。

当重传达16次仍不能成功时就表明同时打算发送帧的站点太多，以至于连续产生碰撞，此时应放弃重传，传并向高层报告 。

#### 共享式以太网的信道利用率 

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%914%20(20).png)

考虑以下这种理想情况:

总线一旦空闲就有某个站点立即发送帧

各站点发送帧都不会产生碰撞

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%914%20(21).png)

![](https://cdn.jsdelivr.net/gh/xiaoyizhiy/testnotebook/%E8%AE%A1%E7%BD%914%20(22).png)

选项B的描述错误，因为CSMA/CD协议不适用于无线网络。对于802.11无线局域网，可以使用CSMA/CA协议。

选项D的描述正确，因为选项D中给出“信号传播延迟趋近于0”，这相当于信号瞬间到达整个网络，网络中各站点瞬间就知道总线被占用，因此不会出现碰撞，进而使信道利用率趋近100%。
