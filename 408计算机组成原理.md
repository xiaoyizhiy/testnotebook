计算机用高电平和低电平来表示0和1。

数字、文字、图像如何用二进制表示?

CPU如何对二进制数进行加减除?

如何存储这些二进制数的?

如何从内存中取出想要的数据?

CPU如何识别和执行我们写的程序?

#### 计算机系统的概述

- 什么是计算机系统
- 硬件的发展
- 软件的发展
- 目前的发展趋势



| 发展阶段         | 名字  | 人物       | 时间      |         逻辑元件         |  速度(次/秒)  | 内存           |              外存              |                                                              |
| ---------------- | ----- | ---------- | --------- | :----------------------: | :-----------: | -------------- | :----------------------------: | ------------------------------------------------------------ |
| 第一代电子管时代 | ENIAC | 冯·诺伊曼  | 1946-1957 |          电子管          |   几千-几万   | 汞延迟线、磁鼓 |         穿孔卡片、纸带         | 有孔表示0，没孔表示1（bug）（这是机器语言）                  |
| 第二代晶体管时代 |       | 贝尔实验室 | 1958-1964 |          晶体管          |  几万-几十万  | 磁芯存储器     |              磁带              | 体积、功耗降低出现面向过程的程序设计语言:FORTRAN有了操作系统雏形 |
| 第三代           |       |            | 1964-1971 |     中小规模集成电路     | 几十万-几百万 | 半导体存储器   |           磁带、磁盘           | 计算机主要用于科学计算等专业用途高级语言迅速发展开始有了分时操作系统 |
| 第四代           |       |            | 1972-现在 | 大规模、超大规模集成电路 |  上千万-万亿  | 半导体存储器   | 磁盘、磁带、光盘、半导体存储器 | 开始出现“微处理器”（CPU）、“微型计算机”、个人计算机(PC)、萌芽操作系统:Windows、MacOs、Linux... |

![image-20241205104933157](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241205104933157.png)
机器字长:计算机一次整数运算所能处理的二进制位数。

1947年，贝尔实验室，发明了“晶体管

1955年，肖克利在硅谷创建肖克利实验室股份有限公司

1957年，八叛徒(traitorous eight)创立(仙童半导体公司

1959年，仙童半导体公司发明“集成电路

1968年，摩尔等人离开仙童，创立Intel

1969年，仙童销售部负责人桑德斯离开仙童，创立 AMD


摩尔定律揭示了信息技术进步的速度集成电路上可容纳的品体管数目，约每18个月便会增加一倍，整体性能也将提升一倍。


机器语言（0/1）

汇编语言（将0/1转换为人类可读的语言）

目前的发展趋势：“两极”分化

- 一极是微型计算机向更微型化网络化、高性能、多用途方向发展;
- 另一极是巨型机向更巨型化、超高速、并行处理、智能化方向发展

###### 早期冯·诺伊曼机

ENIAC每次需要手动接线来控制计算，于是冯·诺依曼提出“存储程序”的概念，将指令以二进制代码的形式事先输入计算机的主存储器（内存），然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。

第一台采用冯·诺依曼结构的计算机EDVAC

![image-20241205111253847](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241205111253847.png)

在计算机系统中软件和硬件在逻辑上是等效的。

对于乘法运算，可以设计一个专门的硬件电路实现乘法运算。也可以用软件的方式，执行多次加法运算来实现。

冯·诺依曼计算机的特点:

- 计算机由五大部件组成

- 指令和数据以同等地位存于存储器，可按地址寻访
- 指令和数据用二进制表示
- 指令由操作码和地址码组成

- 存储程序
- 以运算器为中心

![image-20241205111754483](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241205111754483.png)

销售部门需要生产加工部门的指令才能从仓储部门里拿东西，这显然是低效的。

![image-20241205111911591](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241205111911591.png)

现代计算机:以存储器为中心

CPU=运算器+控制器

![image-20241205112114386](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241205112114386.png)

主存储器：内存（手机运行内存）

辅助存储器：机器硬盘（注意手机中的APP，是在辅助存储器中的，只有当它运行的时候，才将数据放在内存中）（手机的机身存储）

###### 主存储器的基本组成

存储体+MAR+MDR

Memory Address Register(存储地址寄存器) （寄存器：存储二进制数据）

Memory Data Register存储数据寄存器

=菜鸟驿站

货架+店员+柜台

我向店员报取件号，店员按照取件号在货架上找到包裹，最后将它放在柜台上。

流程：

读取：CPU在MAR中找到数据的地址，在存储体中找到数据，然后写入到MDR中，最后取走。

写入：CPU将数据写入MDR，并在MAR中写入存入的地址，最后数据存入到这个地址。

![image-20241205113745277](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241205113745277.png)

存储单元:每个存储单元存放一串二进制代码

存储字(word):存储单元中二进制代码的组合

存储字长:存储单元中二进制代码的位数

存储元:即存储二进制的电子元件，每个存储元可存1bit

存储地址：MAR中存的地址

MAR位数反映存储单元的个数。MAR=2位总共有2^2个存储单元，分别为（二进制）00，01，10，11。

MDR位数=存储字长。MDR=16位→每个存储单元可存放16 bit,1个字(word)= 16 bit

###### 运算器的基本组成

![image-20241205121336697](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241205121336697.png)

运算器:用于实现算术运算(如:加减乘除)、逻辑运算(如:与或非)

ACC（Accumulator）：累加器，用于存放操作数，或运算结果。

MQ（Multiplier Quotient）：乘商寄存器，在乘、除运算时，用于存放操作数或运算结果。

X（ Index Register）：通用的操作数寄存器，用于存放操作数

ALU（Arithmetic Logic Unit）：算术逻辑单元，通过内部复杂的电路实现算数运算、逻辑运算

###### 控制器的基本组成

CU控制单元，分析指令，给出控制信号

IR指令寄存器，存放当前执行的指令

PC程序计数器，存放下一条指令地址，有自动加1功能

###### 计算机的工作过程

![image-20241205121141258](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241205121141258.png)

![image-20241205121336697](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241205121336697.png)

把一个寄存器的名字外面打一个括号，指的是这个寄存器里面的内容，M(MAR)表示的是Memory，指的是主存储器里面的。

初:(PC)=0，指向第一条指令的存储地址

#1：(PC)→MAR（通过地址总线传递），导致(MAR)=0（控制器通过控制总线告诉主存储器这次是读操作）

#3：M(MAR)→MDR，导致(MDR)=000001 0000000101

#4：(MDR)→IR，导致(IR)=000001 0000000101

#5：OP(IR)→CU，指令的操作码送到CU，CU分析后得知，这是“取数”指令  （Operation Code：操作码）

#6：Ad(IR)→MAR，指令的地址码送到MAR，导致(MAR)=5（0000000101的十进制）

#8：M(MAR)→MDR，导致(MDR)=0000000000000010=2

#9：(MDR)→ACC，导致(ACC)=0000000000000010=2

取指令(#1~#4)

分析指令(#5)

执行取数指令(#6 ~ #9)

![image-20241205151639418](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241205151639418.png)

上一条指令取指后PC自动+1，(PC)=1;执行后，(ACC)=2

#1:(PC)→MAR，导致(MAR)=1
#3:M(MAR)→MDR，导致(MDR)=000100 0000000110
#4:(MDR)→IR，导致(IR)=000100  0000000110
#5:OP(IR)→CU，指令的操作码送到CU，CU分析后得知，这是“乘法”指令

#6:Ad(IR)→MAR，指令的地址码送到MAR，导致(MAR)=6

#8:M(MAR)→MDR，导致(MDR)=0000000000000011=3

#9:(MDR)→MQ，导致(MQ)=0000000000000011=3

#10:(ACC)→X，导致(X)=2
#11:(MQ)*(X)→ACC，由ALU实现乘法运算，导致(ACC)=6，如果乘积太大，则需要MQ辅助存储。

取指令(#1~#4)

分析指令(#5)

执行乘法指令(#6~#11)

![image-20241205152851382](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241205152851382.png)

![image-20241205152914922](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241205152914922.png)

###### 计算机系统的层次结构

![image-20241205155240824](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241205155240824.png)

###### 三种级别的语言

编译程序:将高级语言编写的源程序全部语句一次全部翻译成机器语言程序，而后再执行机器语言程序(只需翻译一次)

解释程序：将源程序的一条语句翻译成对应于机器语言的语句，并立即执行。紧接着再翻译下一句(每次执行都要翻译)

计算机中的透明是看不见的

![image-20241205155911478](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241205155911478.png)

###### 存储器的性能指标

MAR位数反映存储单元的个数(最多支持多少个)

MDR位数=存储字长=每个存储单元的大小

总容量 =存储单元个数x存储字长bit

=存储单元个数x存储字长/8 Byte

Eg:MAR为32位，MDR为8位 总容量=2^23*8bit =4GB

注意：

2^10 B=1 KB 10^3 b=1 Kb

2^20 B=1 MB 10^6 b=1 Mb

2^30 B=1 GB  10^9 b=1 Gb

2^40 B=1 TB    10^12 b=1 Tb

######  CPU的性能指标

CPU主频:CPU内数字脉冲信号振荡的频率。（指挥内部器件工作的频率）

CPU时钟周期：一个码元的震荡周期（与主频互为倒数）

CPI（Clock cycle Per Instruction）： 执行一条指令所需的时钟周期数（不同的指令，CPI不同甚至相同的指令，CPI也可能有变化，如从内存中取数，若此时内存负荷过大，则需要的时钟周期越多）。

执行一条指令的耗时=CPI x CPU时钟周期

Eg:某CPU主频为1000 Hz，某程序包含100条指令，平均来看指令的CPI=3。
该程序在该CPU上执行需要多久?

IPS ( instructions Per Second ):每秒执行多少条指令（频率的含义是一秒钟有多少个周期，除以一条指令需要的周期数）

FLOPS(Floating-point Operations Per Second):每秒执行多少次浮点运算

K=Kilo=千=10^3，M=Million=百万=10^6，G=Giga=十亿=10^9，T=Tera=万亿=10^12

###### 系统整体的性能指标

数据通路带宽:数据总线一次所能并行传送信息的位数(各硬件部件通过数据总线传输数据)

吞吐量:指系统在单位时间内处理请求的数量。

响应时间:指从用户向计算机发送一个请求，到系统对该请求做出响应并获得它所需要的结果的等待时间。

基准程序（“跑分软件”）是用来测量计算机处理速度的一种实用程序，以便于被测量的计算机性能可以与运行相同程序的其它计算机性能进行比较。

![image-20241205164335291](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241205164335291.png)

#### 进位计数制 

十进制、二进制、十六进制的英文缩写：D\B\H

数据如何在计算机中表示?
运算器如何实现数据的算数、逻辑运算?

###### 其他进制转换为十进制

推广:r进制计数法 一个数码位乘以一个位权（由位置确定的权重）然后相加。 

![image-20241205170217913](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241205170217913.png)

上图中不是等号。是箭头，即前面的任意的r进制数字，可以通过数码位乘以位权的和转换为十进制数字。

基数:每个数码位所用到的不同符号的个数，r进制的基数为r

二进制0，1

八进制0,1,2,3,4 5,6,7

十进制: 0,1,2,3,4,5,6,7,8,9

十六进制:0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F

![image-20241205171029677](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241205171029677.png)

八进制的加法：5.4+0.4=6

十六进制加法：5.8+0.9=6.1

二进制加法：101.1+11.1=1001

二进制的优点：

①可使用两个稳定状态的物理器件表示（高低电平或正负电荷）

②0，1正好对应逻辑值 假、真。方便实现逻辑运算

③可很方便地使用逻辑门电路实现算术运算

###### 二进制转换为八进制

二进制由两个数字组成，八进制由八个数字组成。因此二进制3个位，就能表示八进制的1个位。

二进制：1111000010 .01101

 001  111  000  010. 011  010（不够三位补0，小数点前的补在前面，小数点后的，补在后面然后每三个一组，和之前一样几进制的就乘以对应的权重，小数点后的，当成没小数点那样算）

1  7  0  2.  3  2

###### 二进制转换成十六进制

4位一组，每组转换成对应的十六进制符号

0011 1100 0010.0110 1000

3  C  2  .  6  8

>转换技巧，将权重写在上面，然后和下面的数字对应相乘相加就行了

###### 八进制转换为二进制

每位八进制对应3个二进制

251.5->010 101 001 . 101 （在010头上写上权值，为421，对应相乘为2）

###### 十六进制转换为二进制

每位十六进制对应的4位二进制

(AE86.1) A为10 E为14，对应1010 1110 1000 0110 . 0001

###### 各种进制的常见书写方式

二进制--(1010001010010)2 2为下标  也可写成1010001010010B
八进制--(1652)8
十六进制--(1652)16  1652 H 0x1652
十进制--(1652)10  1652 D

###### 十进制转换为其他进制 （取余法）

![image-20241206102628535](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241206102628535.png)

除基取余法

![image-20241206103346341](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241206103346341.png)

注意:十进制小数无法用二进制精确表示，因为又出现了0.6

？？？？

乘基取余法

>注意八进制和十六进制的数由二进制转换较为方便，因此如果出现十进制转换为二进制数字可以先转换为二进制，再转换为其他进制。

###### 十进制转换为二进制（拼凑法）

![image-20241206104337954](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241206104337954.png)

先把位权写出来，再凑。

###### 真值和机器数

用二进制的0和1表示十进制的正负。

真值符合人类习惯的数字

机器数:数字实际存到机器里的形式，正负号需要被“数字化

![image-20241206104934704](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241206104934704.png)

#### 无符号整数表示（在硬件中）

即自然数

```c
unsigned short a=1;//无符号整数 短整型 2B
unsigned int b=2;//无符号整数整型，4B
```

无符号整数，在计算机硬件内，如何表示?
无符号整数的加法、减法运算是怎么用硬件实现的?

机器字长=ALU宽度=通用寄存器字长

所以机器字长8位，最多只能同时进行8位运算，通用寄存器只能存8位，

![image-20241207162119983](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241207162119983.png)

无符号整数:

① 全部二进制位都是数值位，没有符号位)第i位的位权是 2^(i-1)

② n bit 无符号整数表示范围 0~2^n-1，超出则溢出，意味着该计算机无法一次处理这么多

③ 可以表示的最小的数 全0，可以表示的最大的数 全1(全1时，表示的十进制的数为2^0+2^1+2^2+……+2^(n-1),等比数列求和为2^n-1)

#### 无符号整数运算（硬件中）

计算机硬件如何做无符号整数的加法：从最低位开始，按位相加，并往更高位进位。

计算机硬件如何做无符号整数的减法：

1. 被减数不变，减数全部位按位取反、末位+1，减法变加法
2. 从最低位开始，按位相加，并往更高位进位

加法电路造价便宜，减法电路造价昂贵。若可将减法转变为加法，省钱!

00001001->11110111

#### 带符号正数

带符号整数，在计算机硬件内，如何表示
带符号整数的加沟碱法运算是怎么用硬件实现的?

同一个带符号的整数可以用不同的编码方式表示：原码、补码、反码。

###### 原码表示

符号位0正1负，第一位为符号位，其他位为数值位。

| 符号位 | 2^6  | 2^5  | 2^4  | 2^3  | 2^2  | 2^1  | 2^0  |
| ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- |

原码:

符号位“0/1”对应“正/负”，剩余的数值位表示真值的绝对值。

 若机器字长n+1位，带符号整数的原码表示范围:-(2^n-1）到2^n-1

真值有两种形式:+0和-0，硬件表示分别为00000000，10000000

常见的书写方法：真值=-19，[x]原=1，0010011  （原为下标）

若未指明机器字长，也可写为:[x]原=1,10011

###### 原码表示的运算

原码的缺点：符号位不能参与运算，需要设计复杂的硬件电路才能处理，费钱!贵!

eg：+19和-19相加后为0，00010011和10010011结果为10100110，错误

用补码表示真值-符号位可以参与运算

###### 原码转换为补码

|      | 原码（便于人类理解） | 怎么转换                                 | 反码             | 怎么转换 | 补码（便于计算机计算） |
| ---- | -------------------- | ---------------------------------------- | ---------------- | -------- | ---------------------- |
| 正数 | [x]原=0，0010011     | 不变                                     | [x]反=0，0010011 | 不变     | [x]补=0，0010011       |
| 负数 | [x]原=1，0010011     | 符号位不变，数值位取反（0变成1，1变成0） | [x]反=1，1101100 | 末位加1  | [x]补=1，1101101       |

负数的原码转换为反码和反码转换成原码转换方法一样，但是反码和补码的相互转换不一样，补码转换为反码，要先转换为原码再转换为补码。

负数的补码先符号位不变，数值位取反（0变成1，1变成0），再末位加1，就变成了原码（即补码的补码是原码）

###### 原码、补码的相互转换（快速转换技巧）

从右往左找到第一个1，这个1左边的所有“数值位”按位取反。

为什么？

###### 补码的加法运算（CSAPP第二章/CS61C）

计算机硬件如何做补码的加法:从最低位开始，按位相加(符号位参与运算)并往更高位进位。

负数的补码数值位不能解读为”位权“（会有高位溢出）

###### 补码的减法运算

将减法转换为等价的加法

[A]补-[B]补=[A]补+[-B]补

接下来要解决的问题:已知“减数”的补码，如何求其负值的补码表示?

全部位按位取反、末位+1/第一个1不变，左边的所有位按位取反

计算机硬件如何做带符号数补码的减法:

1. “被减数”不变，减数全部位按位取反、末位+1，减法变加法
2. 从最低位开始，按位相加，并往更高位进位

有符号的补码的运算和无符号的运算一致，共用一套电路。

![image-20241207181039454](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241207181039454.png)

补码可以带着符号位直接计算。

#### 定点数的编码表示

定点数:小数点的位置固定 Eg:996.007--常规计数
浮点数:小数点的位置不固定Eg:9.96007*10^2--科学计数法

编码表示：

- 无符号数
- 有符号数：原码、反码、补码、移码（重点）

###### 无符号数的表示（通常只有无符号整数而没有无符号小数）

整个机器字长的全部二进制位均为数值位，没有符号位，相当于数的绝对值。

![image-20250117170356572](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20250117170356572.png)

表示范围：

如用8位二进制数来表示：能表示2^8个数，以0开始，所以范围为：0~255

所以n位的无符号数表示范围为:0~2^n-1

 ###### 有符号数的定点表示

![image-20250117172018600](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20250117172018600.png)

符号位：0表示正，1表示负。

尾数：即数值部分。

![image-20250117172049404](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20250117172049404.png)

注:可用原码、反码、补码 三种方式来表示定点整数和定点小数。还可用移码表示定点整数。

若真值为 x，则用 [x]原、[x]反、[x]补、[x]移分别表示真值所对应的原码、反码、补码、移码。

###### 原码

用尾数表示真值的绝对值，符号位“0/1”对应“正/负。（若机器字长为n+1位，则尾数占n位，符号位） 

定点整数 

![image-20250118111714925](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20250118111714925.png)

上图为小数点隐含在最后一位，下图为小数点隐含在其他位。

![image-20250118111905059](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20250118111905059.png)

常写为:[x]原=1,0010011(指明机器字长)，也可写为:[x]原=1,10011(未指明机器字长)

定点小数

![image-20250118112157668](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20250118112157668.png)

常写为:[x]原=0.1100000（第一个零表示符号位）

 ###### 原码的表示范围

![image-20250118113820691](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20250118113820691.png)

若机器字长n+1位，原码整数的表示范围:-(2^n-1) ≤ x ≤2^n-1(关于原点对称)

真值0有+0 和-0 两种形式

![image-20250118113759571](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20250118113759571.png)

若机器字长n+1位，原码小数的表示范围:-(1-2^(-n) ≤ x ≤1-2^(-n)(关于原点对称)

真值0有+0 和-0 两种形式.

###### 反码

若符号位为0，则反码与原码相同。若符号位为1，则数值位全部取反

x= +19 D  [x]原= 0，0010011  [x]反= 0，0010011
x= -19 D  [x]原= 1，0010011  [x]反= 1，1101100
x= +0.75 D  [x]原= 0.1100000  [x]反= 0.1100000
x= -0.75 D  [x]原= 1.1100000  [x]反= 1.0011111

若机器字长n+1位，反码整数的表示范围:-(2^n-1) ≤ x ≤2^n-1(关于原点对称)

真值0有+0 和-0 两种形式

[+0]原=00000000  [+0]反=00000000
[-0]原=10000000  [-0]反=11111111

若机器字长n+1位，反码小数的表示范围:-(1-2^(-n) ≤ x ≤1-2^(-n)(关于原点对称)

真值0有+0 和-0 两种形式.

“反码”只是“原码”转变为“补码”的一个中间状态，实际中并没什么卵用。

###### 补码（只有补码的符号位可以直接计算）

正数的补码=原码

负数的补码=反码末位+1(要考虑进位)

负数的原码=将负数补码转回原码的方法相同:尾数取反，末位+1

x= +19 D  [x]原= 0，0010011  [x]反= 0，0010011  [x]补= 0，0010011
x= -19 D  [x]原= 1，0010011  [x]反= 1，1101100  [x]反= 1，1101101
x= +0.75 D  [x]原= 0.1100000  [x]反= 0.1100000  [x]反= 0.1100000
x= -0.75 D  [x]原= 1.1100000  [x]反= 1.0011111  [x]反= 1.0100000

[+0]原=00000000  [+0]反=00000000  [+0]补=00000000
[-0]原=10000000  [-0]反=11111111  [-0]补=00000000  （末尾加1，变成了100000000，补码的符号位直接参与运算，结果会溢出，变成了9位，而机器字长为8位，则丢弃第9位的1，变成了00000000）

则[+0]补=[-0]补=00000000 补码的真值0只有一种表示形式

定义整数补码1，0000000表示成-2^7，若机器字长n+1位，补码整数的表示范围:-2^n ≤ x ≤2^n-1(比原码多表示一个 -2^n)

定义小数补码1.0000000表示成-1，若机器字长n+1位，补码小数的表示范围:-1 ≤ x ≤1-2^(-n)(比原码多表示一个(-1)

###### 移码

补码的基础上将符号位取反。注意:移码只能用于表示整数

[+0]=[-0]= 00000000
注意!补码的真值0只有一种表示形式
[+0]移=[-0]移= 10000000

若机器字长n+1位，移码整数的表示范围:-2^n≤x≤2^n-1(与补码相同)

![image-20250118134344793](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20250118134344793.png)

将移码看成是一个无符号的数，则移码表示的整数很方便对比大小。（计算机硬件只要从高位开始比较那个数先出现1即可，若同时出现则继续向低位比较）

![image-20250118134601746](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20250118134601746.png)

原码和反码的真值0有两种表示
补码和移码的真值0只有一种表示，补码和移码可以多表示一个负数。

###### 练习

![image-20250118140047163](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20250118140047163.png)

![image-20250118140109617](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20250118140109617.png)

![image-20250118140150471](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20250118140150471.png)

###### 各种码的作用

​                                                                  