#### 一天看两个小时，两周看完!!!!

12.8  1.1.1-1.4.2 共116分钟

12.9  1.5-2.1.4 共125分钟

12.10 2.1.5-2.2.1的一半 共40分钟

#### 操作系统的概念和定义

操作系统(Operating system，OS)是指

- 控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配;（操作系统是系统资源的管理者）
- 以提供给用户和其他软件方便的接口和环境;（向上层提供方便易用的服务）
- 它是计算机系统中最基本的系统软件。（是最接近硬件的一层软件）

提供的功能

- 处理机管理
- 存储器管理
- 文件管理
- 设备管理

向上层提供方便易用的服务：

GUI:图形化用户接口(Graphical User Interface)：用户可以使用形象的图形界面进行操作，而不再需要记忆复杂的命令、参数。

联机命令接口（交互式命令接口）：用户说一句，系统跟着做一句（AIT+R打开命令行窗口，输入一条命令，返回一个结果）

脱机命令接口（批处理命令接口）：用户说一堆，系统跟着做一堆，使用windows系统的搜索功能，搜索C盘中的*.bat文件，用记事本任意打开一个

程序接口:可以在程序中进行系统调用（广义指令）来使用程序接口。普通用户不能直接使用程序接口，只能通过程序代码间接使用。（如:写C语言“Hello world”程序时，在printf 函数的底层就使用到了操作系统提供的显式相关的“系统调用”）

![image-20241208155106672](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241208155106672.png)

![image-20241208155250292](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241208155250292.png)

计算机系统实现对硬件机器的拓展：

类比汽车:发动机--只会转;轮胎--只会滚;
在原始的硬件机器上覆盖一层传动系统--让发动机带着轮子转--使原始的硬件机器得到拓展

操作系统对硬件机器的拓展:将CPU、内存、磁盘、显示器、键盘等硬件合理地组织起来，让各种硬件能够相互协调配合，实现更多更复杂的功能，

#### 操作系统的特征

###### 并发

并发:指两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的。

并行:指两个或多个事件在同一时刻同时发生。

操作系统就是伴随着“多道程序技术”而出现的。因此，操作系统和程序并发是一起诞生的。

注意(重要考点):

单核CPU同一时刻只能执行一个程序，各个程序只能并发地执行多核CPU同一时刻可以同时执行多个程序，多个程序可以并行地执行。
比如Intel的第八代i 3处理器就是4核CPU，意味着可以并行地执行4个程序。

###### 共享

共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。

分为：

- 互斥共享方式：系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源
- 同时共享方式：系统中的某些资源，允许一个时间段内由多个进程“同时”对它们进行访问

所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问的(即分时共享)

生活实例:

互斥共享方式:使用QQ和微信视频。同一时间段内摄像头只能分配给其中一个进程。

同时共享方式:使用QQ发送文件A，同时使用微信发送文件B。宏观上看，两边都在同时读取并发送文件，说明两个进程都在访问硬盘资源，从中读取数据。微观上看，两个进程是交替着访问硬盘的。

###### 并发与共享的关系

使用QQ发送文件A，同时使用微信发送文件B。

- 两个进程正在并发执行(并发性)  如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义

- 需要共享地访问硬盘资源(共享性)  如果失去共享性，则QQ和微信不能同时访问硬盘资源，就无法实现同时发送文件，也就无法并发


###### 虚拟

 虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体(前者)是实际存在的，而逻辑上对应物(后者)是用户感受到的。

Yo~用一个例子来理解背景知识:一个程序需要放入内存并给它分配CPU才能执行

GTA5需要4GB的运行内存，QQ需要256MB的内存，迅雷需要256MB的内存，网易云音乐需要256MB的内存.…

我的电脑:4GB内存

问题:这些程序同时运行需要的内存远大于4GB，那么为什么它们还可以在我的电脑上同时运行呢?
这是虚拟存储器技术（虚拟技术中的“空分复用技术”），实际只有4GB的内存，在用户看来似乎远远大于4GB

虚拟技术的分类：

- 空分复用技术(如虚拟存储器技术)
- 时分复用技术(如虚拟处理器)

显然，如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了。因此，没有并发性，就谈不上虚拟性。

###### 异步

异步是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限（打印机、摄像头），进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。

一号的指令1:老渣陪我吃饭  一号的指令2:老渣把心给我  第一道程序
二号的指令1:老渣把心给我  二号的指令2:老渣陪我吃饭  第二道程序

如果失去了并发性，即系统只能串行地运行各个程序，那么每个程序的执行会一贯到底。只有系统拥有并发性，才有可能导致异步性。

![image-20241208161307865](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241208161307865.png)

#### 操作系统的发展与分类
|        | 手工操作阶段                                 | 批处理阶段（单道批处理系统、多道批处理系统）                 | 分时操作系统                                                 | 实时操作系统                                                 | 网络操作系统 | 分布式操作系统 | 个人计算机操作系统 |
| ------ | -------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------ | -------------- | ------------------ |
| 优缺点 | 用户独占全机、人机速度矛盾导致资源利用率极低 | 主要优点:缓解了一定程度的人机速度矛盾，资源利用率有所提升。<br/>主要缺点:内存中仅能有一道程序运行，只有该程序运行结束之后才能调入下一道程序。CPU有大量的时间是在空闲等待I/0完成。资源利用率依然很低。 | 主要优点：用户请求可以被即时响应，解决了人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。<br/>主要缺点:不能优先处理一些紧急任外。操作系统对各个用户/作业都是完全公平的，循环地为每个用户作业服务一个时间片，不区分任务的紧急性。 | 主要优点:能够优先响应一些紧急任务，某些紧急任务不需时间片排队。 |              |                |                    |
|        |                                              | 主要优点:多道程序并发执行，共享计算机资源。资源利用率大幅提升，CPU和其他资源更能保持“忙碌”状态，系统吞吐量增大。<br/>主要缺点:用户响应时间长，没有人机交互功能(用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行。eg:无法调试程序/无法在程序运行过程中输入一些参数) |                                                              |                                                              |              |                |                    |

手工阶段：程序员将数据以打孔的方式放入纸带机中（慢），计算机中读入数据（慢），计算机进行计算（快），计算机在纸带机上打孔（慢），程序员从纸上读取数据（慢）。

单道批：引入脱机输入/输出技术(用外围机+磁带完成，通过外围机把程序提前存到磁带里)，并由监督程序（操作系统的雏形）负责控制作业的输入、输出。

多道批：单道批的扩展，计算第二个程序时，输入第三个程序，输出第一个程序。（操作系统正式诞生，用于支持多道程序并发运行）

分时操作系统:计算机以时间片为单位轮流为各个用户/作业服务，各个用户可通过终端与计算机进行交互。

实时操作系统:在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完事件。实时操作系统的主要特点是及时性和可靠性。

分为：

- 硬实时系统：必须在绝对严格的规定时间内完成处理，如:导弹控制系统自动驾驶系统
- 软实时系统：能接受偶尔违反时间规定，如:12306火车订票系统（余票数量的更新时间可接受几秒钟的延迟）

网络操作系统:是伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机地结合起来，实现数据传送等功能，实现网络中各种资源的共享(如文件共享)和各台计算机之间的通信。(如:Windows NT 就是一种典型的网络操作系统，网站服务器就可以使用)

分布式操作系统:主要特点是分布性和并行性。系统中的各台计算机地位相同，任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务。

个人计算机操作系统:如WindowsXP、Macos，方便个人使用。

![image-20241208163521319](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241208163521319.png)

#### 操作系统的运行机制

“指令”就是处理器(CPU)能识别、执行的最基本命令

注:很多人习惯把 Linux、Windows、MacOs的“小黑框”中使用的命令也称为“指令”，其实这是“交互式命令接口”，注意与本节的“指令”区别开。本节中的“指令”指二进制机器指令。

###### 内核程序 v.s. 应用程序

我们普通程序员写的程序就是应用程序

微软、苹果有一帮人负责实现操作系统，他们写的是“内核程序”由很多内核程序组成了“操作系统内核”，或简称“内核(Kernel)

内核是操作系统最重要最核心的部分，也是最接近硬件的部分甚至可以说，一个操作系统只要有内核就够了(eg:Docker->仅需Lnux内核)

操作系统的功能未必都在内核中，如图形化用户界面GUI

操作系统内核作为“管理者”，有时会让CPU执行一些“特权指令”，如:内存清零指令。这些指令影响重大，只允许“管理者”--即操作系统内核来使用。

应用程序只能使用“非特权指令”，如:加法指令、减法指令等。

在CPU设计和生产的时候就划分了特权指令和非特权指令，因此CPU执行一条指令前就能判断出其类型。

###### 内核态 v.s.用户态

CPU 能判断出指令类型，但是它怎么区分此时正在运行的是内核程序or 应用程序?

CPU有两种状态，“内核态”和“用户态

处于内核态时，说明此时正在运行的是内核程序，此时可以执行

特权指令处于用户态时，说明此时正在运行的是应用程序，此时只能执行非特权指令

拓展:CPU中有一个寄存器叫程序状态字寄存器(PSW)，其中有个二进制位，1表示“内核态”，0表示“用户态。

###### 内核态与用户态的切换

1. 刚开机时，CPU为“内核态”，操作系统内核程序先上CPU运行（开机时，初始化操作系统）
2. 开机完成后，用户可以启动某个应用程序
3. 操作系统内核程序在合适的时候主动让出CPU，让该应用程序上CPU运行（操作系统内核在让出CPU之前，会用一条特权指令把 PSW 的标志位设置为“用户态”）
4. 应用程序运行在“用户态”
5. 此时，一位猥琐黑客在应用程序中植入了一条特权指令，企图破坏系统CPU发现接下来要执行的这条指令是特权指令，但是自己又处于“用户态“
6. 这个非法事件会引发一个中断信号（CPU检测到中断信号后，会立即变为“核心态”，并停止运行当前的应用程序，转而运行处理中断信号的内核程序）
7. “中断”使操作系统再次夺回CPU的控制权
8. 操作系统会对引发中断的事件进行处理，处理完了再把CPU使用权交给别的应用程序

![image-20241208170835600](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241208170835600.png)

#### 中断和异常

###### 中断的作用

CPU 上会运行两种程序，一种是操作系统内核程序（是整个系统的管理者），一种是应用程序。

“中断”是让操作系统内核夺回CPU使用权的唯一途径，如果没有“中断”机制，那么一旦应用程序上CPU运行，CPU就会一直运行这个应用程序。

内核态→用户态：执行一条特权指令--修改PSW的标志位为“用户态”，这个动作意味着操作系统将主动让出CPU使用权。

用户态→内核态：由“中断”引发，硬件自动完成变态过程，触发中断信号意味着操作系统将强行夺回CPU的使用权。

###### 中断的类型

内中断：与当前执行的指令有关，中断信号来源于CPU内部。
外中断：与当前执行的指令无关，中断信号来源于CPU外部。

###### 内中断

- 例子1:试图在用户态下执行特权指令
- 例子2:执行除法指令时发现除数为0 （若当前执行的指令是非法的，则会引发一个中断信号）
  
- 例子3:有时候应用程序想请求操作系统内核的服务，此时会执行一条特殊的指令--陷入指令（非特权指令），该指令会引发一个内部中断信号（执行“陷入指令”，意味着应用程序主动地将CPU控制权还给操作系统内核。“系统调用”就是通过陷入指令完成的）

###### 外中断

- 例子1:时钟中断--由时钟部件发来的中断信号（程序并发执行：时钟部件每隔一个时间片，会给CPU发送一个时钟中断信号） （执行程序1的指令1，到时间了收到中断信号，操作系统转换为内核态并停止执行应用程序并处理时钟中断信号，即分析出程序1的指令1到时，此时结束，转换为用户态，执行程序2的指令1）
- 例子2:I/0中断--由输入/输出设备发来的中断信号，当输入输出任务完成时，向CPU发送中断信号

![image-20241208172527188](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241208172527188.png)

###### 中断机制的基本原理

不同的中断信号，需要用不同的中断处理程序来处理。当CPU检测到中断信号后，会根据中断信号的类型去查询“中断向量表”，以此来找到相应的中断处理程序在内存中的存放位置。

显然，中断处理程序一定是内核程序，需要运行在“内核态”。

![image-20241208172752393](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241208172752393.png)

#### 系统调用

操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务。主要包括命令接口和程序接口。其中，程序接口由一组系统调用组成。

“系统调用”是操作系统提供给应用程序(程序员/编程人员)使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以通过系统调用来请求获得操作系统内核的服务。

| 普通应用程序 | 可直接进行系统调用，也可使用库函数，有的库函数涉及系统调用，有的不涉及 |
| ------------ | ------------------------------------------------------------ |
| 编程语言     | 向上提供库函数。有时会将系统调用封装成库函数，以隐藏系统调用的一些细节，使程序员编程更加方便。 |
| 操作系统     | 向上提供系统调用，使得上层程序能请求内核的服务               |
| 裸机         |                                                              |

不涉及系统调用的库函数:如的“取绝对值”的函数

涉及系统调用的库函数:如“创建一个新文件”的函数

###### 小例子:为什么系统调用是必须的?

生活场景:去学校打印店打印论文，你按下了WPS的“打印”选项，打印机开始工作。你的论文打印到一半时，另一位同学按下了Word 的“打印”按钮，开始打印他自己的论文。
思考:如果两个进程可以随意地、并发地共享打印机资源，会发生什么情况?
两个进程并发运行，打印机设备交替地收到WPS和 Word 两个进程发来的打印请求，结果两篇论文的内容混杂在一起了…

解决方法:由操作系统内核对共享资源进行统一的管理，并向上提供“系统调用”，用户进程想要使用打印机这种共享资源，只能通过系统调用向操作系统内核发出请求。内核会对各个请求进行协调处理。

###### 系统调用的分类

按功能分：

设备管理：完成设备的 请求/释放/启动 等功能
文件管理：完成文件的 读/写/创建/删除 等功能
进程控制：完成进程的 创建/撤销/阻塞/唤醒 等功能
进程通信：完成进程之间的 消息传递/信号传递 等功能
内存管理：完成内存的 分配/回收 等功能

应用程序通过系统调用请求操作系统的服务。而系统中的各种共享资源都由操作系统内核统一掌管，因此凡是与共享资源有关的操作(如存储分配、I/0操作、文件管理等)，都必须通过系统调用的方式向操作系统内核提出服务请求，由操作系统内核代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。

###### 系统调用的过程

应用程序发  传参指令1（指明系统调用类型，如fork）  到  CPU的寄存器

应用程序发  陷入指令  到  CPU的寄存器  （该中断由陷入指令引发，因此转入相应的中断处理程序--即 系统调用的入口程序（内核态））

系统调用入口程序 根据寄存器中的参数判断用户需要fork系统调用服务

fork 系统调用的处理程序发指令到CPU中

结束完成后继续执行应用程序的下一条指令 

![image-20241208175236556](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241208175236556.png)

![image-20241208175346561](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241208175346561.png)

#### 操作系统的体系结构

内核怎么设计？

![image-20241208175530574](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241208175530574.png)

操作系统内核分为：

- 时钟管理：实现计时功能
- 中断处理：负责实现中断机制
- 原语：是一种特殊的程序、处于操作系统最底层，是最接近硬件的部分、这种程序的运行具有原子性其运行只能一气呵成，不可中断、运行时间较短、调用频繁
- 对系统资源进行管理的功能：进程管理、存储器管理、设备管理

时钟管理、中断处理、原语是与硬件关联较紧密的模块
对系统资源进行管理的功能这些管理工作更多的是对数据结构的操作，不
会直接涉及硬件。

###### 大内核（又名:宏内核/单内核)）

全部包含

###### 微内核

只包含时钟管理、中断处理、原语。故对系统资源进行管理的功能：进程管理、存储器管理、设备管理这些要使用时，必须转换为用户态才能使用。（操作系统状态的转换的过程是有成本的，要消耗不少时间，频繁地变态会降低系统性能）


![image-20241208180438335](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241208180438335.png)

|                 | 特性思想                                                     |                             优点                             |                             缺点                             |
| --------------- | :----------------------------------------------------------- | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 分层结构        | 内核分多层，每层可单向调用（相邻）更低一层提供的接口         | 1.便于调试和验证，自底向上逐层调试验证<br/>2.易扩充和易维护，各层之间调用接口清晰固定 | 1.仅可调用相邻低层，难以合理定义各层的边界<br/>2.效率低，不可跨层调用，系统调用执行时间长 |
| 模块化          | 将内核划分为多个模块，各模块之间相互协作。内核 =主模块+可加载内核模块  主模块:只负责核心功能，如进程调度、内存管理  <br/>可加载内核模块:可以动态加载新模块到内核而无需重新编译整个内核（驱动） | 1.模块间逻辑清晰易于维护，确定模块间接口后即可多模块同时开发<br/>2.支持动态加载新的内核模块(如:安装设备驱动程序、安装新的文件系统模块到内核)，增强OS适应性<br/>3.任何模块都可以直接调用其他模块，无需采用消息传递进行通信，效率高 | 1.模块间的接口定义未必合理、实用<br/>2.模块间相互依赖，更难调试和验证 |
| 宏内核(大内核)  | 所有的系统功能都放在内核里(大内核结构的OS通常也采用了"模块化"的设计思想) |          性能高，内核内部各种功能都可以直接相互调用          | 1.内核庞大功能复杂，难以维护<br/>2.大内核中某个功能模块出错，就可能导致整个系统崩溃 |
| 微内核          | 只把中断、原语、进程通信等最核心的功能放入内核。进程管理、文件管理、设备管理等功能以用户进程的形式运行在用户态 | 1.内核小功能少、易于维护，内核可靠性高<br/>2.内核外的某个功能模块出错不会导致整个系统崩溃 | 1.性能低，需要频繁的切换 用户态/核心态。<br/>2.用户态下的各功能模块不可以直接相互调用，只能通过内核的”消息传递“来间接通信（进程管理、存储管理、设备管理与时钟管理、中断处理、原语之间的联系） |
| 外核(exokernel) | 内核负责进程调度、进程通信等功能，外核负责为用户进程分配未经抽象的硬件资源，且由外核负责保证资源使用安全 | 1.外核可直接给用户进程分配“不虚拟、不抽象”的硬件资源，使用户进程可以更灵活的使用硬件资源<br/>2.减少了虚拟硬件资源的”映射层”，提升效率 |         1.降低了系统的一致性<br/>2.使系统变得更复杂          |

###### 分层结构

![image-20241208181501798](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241208181501798.png)

1.自下向上逐层调试

2.便于新加：向上提供的不变就可

1.各层的功能会相同，并且低层会用到相邻的高层的功能，

2.有时高层要用到最底层的，但是必须逐层

###### 模块化

1.该模块有3个接口，只要先确定了要连接的模块的接口相同，就可以专心开发自己的模块了。

2.新的模块直接加入就可

3.直接调用函数就能使用其他模块了

1.因为相互调用的次数多，所以接口的定义可能会不合理

2.不知道是自身有问题还是调用的模块有问题

###### 外核（虚拟内存）

外核负责为用户进程分配未经抽象的硬件资源。

#### 操作系统引导

操作系统引显(boot)--开机的时候,怎么让操作系统行起来?

###### 磁盘

- 主引导记录(MBR) 包含：磁盘引导程序和分区表（数据结构）
- C盘：是这个磁盘的活动分区，安装了操作系统。细分为：引导记录PBR（负责找到“启动管理器”、根目录、其他
- D盘：
- E盘：
- F盘：

CPU（主存）分为RAM、ROM(BIOS)包含:ROM引导程序即自举程序

操作系统引导:

①CPU从一个特定主存地址开始>取指令，执行ROM中的引导程序(先进行硬件自检，再开机)

②将磁盘的第一块--主引导记录读入内存，执行磁盘引导程序，扫描分区表

③从活动分区(又称主分区，即安装了操作系统的分区)读入分区引导记录，执行其中的程序

④从根目录下找到完整的操作系统初始化程序(即启动管理器)并执行，完成“开机”的一系列动作

#### 虚拟机

物理机器（硬件）的性能高，但是一台机器只能运行一个操作系统，但是多个进程可能会相互干扰。

虚拟机:使用虚拟化技术，将一台物理机器虚化为多台虚拟机器(Virtual Machine,VM)，每个虚拟机器都可以独立运行一个操作系统。
同义术语:虚拟机管理程序/虚拟机监控程序（Virtual Machine Monitor/ Hypervisor）

###### 第一类VMM，直接运行在硬件上

![image-20241209110149556](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241209110149556.png)

每一台虚拟机器上可以安装各自的操作系统。

CPU划分多个时间片给各个操作系统（各个操作系统运行在用户态，但是它们不知道自己在用户态，但他们执行特权指令时，虚拟机管理程序截获并帮它们执行）

###### 第二类VMM，运行在宿主操作系统上

![image-20241209110531550](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241209110531550.png)

第二类虚拟机管理程序运行在宿主操作系统上（注意:学校开机选系统的是多系统,不是虚拟机,因为如果是虚拟机,你可以同时操作多个操作系统,但是学校的每次开机只能选一个,要换只能重启,别被误导了）

###### 两类虚拟机管理程序(VMM)的对比

|                    | 第一类VMN                                                    | 第二类VMN                                                    |
| ------------------ | :----------------------------------------------------------- | :----------------------------------------------------------- |
| 对物理资源的控制权 | 直接运行在硬件之上，能直接控制和分配物理资源                 | 运行在Host OS之上，依赖于Host Os为其分配物理资源             |
| 资源分配方式       | 在安装Guest OS时，VMM要在原本的硬盘上自行分配存储空间，类似于“外核”的分配方式，分配未经抽象的物理硬件 | Guest Os 拥有自己的虚拟磁盘，该盘实际上是Host Os 文件系统中的一个大文件。Guest Os分配到的内存是虚拟内存 |
| 性能               | 性能更好                                                     | 性能更差，需要Host OS作为“中介"                              |
| 可支持的虚拟机数量 | 更多，不需要和 Host OS 竞争资源，相同的硬件资源可以支持更多的虚拟机 | 更少，Host OS 本身需要使用物理资源，Host OS 上运行的其他进程也需要物理资源 |
| 虚拟机的可迁移性   | 更差                                                         | 更好，只需导出虚拟机镜像文件即可迁移到另一台 Host Os上，商业化应用更广泛 |
| 运行模式           | 第一类VMM运行在最高特权级(Ring 0)，可以执行最高特权的指令。  | 第二类VMM部分运行在用户态、部分运行在内核态。Guest Os 发出的系统调用会被 VMM 截获，并转化为 VMM 对 Host Os 的系统调用 |

#### 进程

###### 进程的概念

打开任务管理器，可以同时打开三个QQ，显示三个QQ的进程

程序:是静态的，就是个存放在磁盘里的可执行文件，就是一系列的指令集合。

进程(Process):是动态的，是程序的一次执行过程。（同一个程序多次执行会对应多个进程）

思考:操作系统是这些进程的管理者，它要怎么区分各个进程?

当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的“身份证号”-- PID(Process lD，进程ID) （每次新加一个进程有一个新的PID，同一个软件打开关闭，PID不同）

操作系统要记录PID、进程所属用户ID(UID)、还要记录给进程分配了哪些资源、还要记录进程的运行情况，这些信息都被保存在一个数据结构PCB(Process Control Block)中，即进程控制块。操作系统需要对各个并发运行的进程进行管理，但凡管理时所需要的信息，都会被放在PCB中。

![image-20241209112850238](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241209112850238.png)

![image-20241209113759990](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241209113759990.png)

程序段、数据段、PCB三部分组成了进程实体(进程映像)引入进程实体的概念后，可把进程定义为:进程是进程实体的运行过程，是系统进行资源分配和调度（一个进程被“调度”，京就是指操!作系统决定让这个进程上CPU运行）的一个独立单位。
注意:PCB是进程存在的唯一标志!

![image-20241209113930313](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241209113930313.png)

![image-20241209113937206](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241209113937206.png)

#### 进程的状态的转换

进程正在被创建时，它的状态是“创建态”，在这个阶段操作系统会为进程分配资源、初始化PCB

当进程创建完成后，便进入“就绪态”处于就绪态的进程已经具备运行条件，但由于没有空CPU，就暂时不能运行。

系统中可能会有很多个进程都处于就绪态。

当CPU空闲时，操作系统就会选择一个就绪进程，让它上处理机运行。

如果一个进程此时在CPU上运行，那么这个进程处于“运行态”CPU会执行该进程对应的程序(执行指令序列)。

在进程运行的过程中，可能会请求等待某个事件的发生(如等待某种系统资源的分配，或者等待其他进程的响应) （系统调用）。

在这个事件发生之前，进程无法继续往下执行，此时操作系统会让这个进程下CPU，并让它进入“阻塞态“。

当CPU空闲时，又会选择另一个“就绪态”进程上CPU运行。

当申请的资源被分配，或等待的事件发生，此时操作系统会让这个进程上CPU，并让它进入“就绪态“。

进程运行结束，或运行过程中遇到不可修复的错误（除以0），可以执行exit 系统调用，请求操作系统终止该进程。此时该进程会进入“终止态”，操作系统会让该进程下CPU并回收内存空间等资源，最后还要回收该进程的PCB。

当终止进程的工作完成之后，这个进程就彻底消失了。

运行态→阻塞态是一种进程自身做出的主动行为；阻塞态→就绪态是不是进程自身能控制的，是一种被动行为

注意:不能由阻塞态直接转换为运行态也不能由就绪态直接转换为阻塞态(因为进入阻塞态是进程主动请求的，必然需要进程在运行时才能发出这种请求)

时间片到（时钟中断 ，这是外部中断），或处理机被抢占时，会从运行态直接转换为就绪态

![image-20241209115153908](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241209115153908.png)

![image-20241209115317568](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241209115317568.png)

进程PCB中，会有一个变量 state 来表示进程的当前状态。如:1表示创建态、2表示就绪态、3表示运行态...
为了对同一个状态下的各个进程进行统一的管理，操作系统会将各个进程的PCB组织起来。

###### 进程的组织--链接方式

操作系统如何将各个进程的PCB组织起来？

![image-20241209115759827](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241209115759827.png)

![image-20241209115841909](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241209115841909.png)

进程的组织方式：

- 链接方式：按照进程状态将PCB分为多个队列、操作系统持有指向各个队列的指针
- 索引方式：根据进程状态的不同，建立几张索引表、操作系统持有指向各个索引表的指针


![image-20241209120015819](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241209120015819.png)

#### 进程控制

###### 什么是进程控制

进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。

简化理解:反正进程控制就是要实现进程状态转换

###### 如何实现进程控制

要使用原语，它是一种特殊的程序，它的执行具有原子性也就是说，这段程序的运行必须一气呵成，不可中断。如果不能“一气呵成”，就有可能导致操作系统中的某些关键数据结构信息不统一的情况，这会影响操作系统进行别的管理工作。

###### 如何实现原语的“原子性”?

原语的执行具有原子性，即执行过程只能一气呵成，期间不允许被中断。可以用“关中断指令”和“开中断指令”这两个特权指令实现原子性。

正常情况:CPU每执行完一条指令都会例行检查是否有中断信号需要处理，如果有，则暂停运行当前这段程序，转而执行相应的中断处理程序。

CPU执行了关中断指令之后，就不再例行检查中断信号，直到执行开中断指令之后才会恢复检查。

执行指令1，执行指令2，执行关中断指令，执行指令a，此时有外部中断信号，但是不管它，执行指令b，执行开中断指令。

###### 进程控制相关的原语

进程的创建：

- 创建原语（操作系统创建一个进程时使用的原语）：申请空白PCB、为新进程分配所需资源、初始化PCB、将PCB插入就绪队列（创建态→就绪态）
- 引起进程创建的事件：用户登录（分时系统中，用户登录成功，系统会建立为其建立一个新的进程）、作业调度（多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程）、提供服务（用户向操作系统提出某些请求时，会新建一个进程处理该请求）、应用请求（由用户进程主动请求创建一个子进程）

进程的终止：

- 撤销原语（就绪态/阻塞态/运行态
  →终止态→无）：从PCB集合中找到终止进程的PCB、若进程正在运行，立即剥夺CPU，将CPU分配给其他进程、终止其所有子进程、将该进程拥有的所有资源归还给父进程或操作系统、删除PCB
- 引起进程终止的事件：正常结束-进程自己请求终止(exit系统调用)、异常结束-整数除以0、非法使用特权指令,然后被操作系统强行杀掉、外界干预-Ctrl+Alt+delete，用户选择杀掉进程

进程的阻塞和唤醒（阻塞原语唤醒原语必须成对使用）：

进程的阻塞：

- 阻塞原语（运行态→阻塞态）：找到要阻塞的进程对应的PCB、保护进程运行的现场，将PCB状态信息设置为“阻塞态"，暂时停止进程运行、将PCB插入相应事件的等待队列
- 引起进程阻塞的事件：需要等待系统分配某种资源、需要等待相互合作的其他进程完成工作

进程的唤醒：

- 唤醒原语（阻塞态→就绪态）：在事件等待队列中找到PCB、将PCB从等待队列移除，设置进程为就绪态、将PCB插入就绪队列，等待被调度

- 引起进程唤醒的事件：等待的事件发生

进程的切换：

- 切换原语（运行态→就绪态、就绪态→运行态）：将运行环境信息（进程上下文）存入PCB、PCB移入相应队列、选择另一个进程执行，并更新其PCB、根据PCB恢复新进程所需的运行环境
- 引起进程切换的事件：当前进程时间片到、有更高优先级的进程到达、当前进程主动阻塞、当前进程终止


![image-20241209154931283](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241209154931283.png)

![image-20241209155009924](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241209155009924.png)
无论哪个进程控制原语，要做的无非三类事情:

1.更新PCB中的信息（修改进程状态保存/恢复运行环境）

2.将PCB插入合适的队列

3.分配/回收资源

#### 进程通信

进程间通信(Inter-Process Communication，IPC)是指两个进程之间产生数据交互。（微博分享到微信）

为什么进程通信需要操作系统支持?

进程是分配系统资源的单位(包括内存地址空间)，因此各进程拥有的内存地址空间相互独立。

进程只能访问自己的内存空间（安全考虑）

进程通信的分类：

- 共享存储

- 消息传递
- 管道通信

###### 共享存储

进程除了自己的存储空间外，还有一个共享存储区。 

为避免出错，各个进程对共享空间的访问应该是互斥的。（一次只能一个进程存储，防止覆盖）

各个进程可使用操作系统内核提供的同步互斥工具(如P、V操作)

基于存储区的共享（高级）:操作系统在内存中划出一块共享存储区，数据的形式、存放位置都由通信进程控制，而不是操作系统。这种共享方式速度很快，是一种高级通信方式。

基于数据结构的共享（低级）:比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信方式。

###### 消息传递

进程间的数据交换以格式化的消息(Message)为单位。进程通过操作系统提供的“发送消息/接收

消息”两个原语进行数据交换。

消息头

消息体

消息头包括:发送进程ID、接受进程ID、消息长度等格式化的信息。

消息体：要发送的数据。

消息传递：

- 直接通信方式：消息发送进程要指明接收进程的ID
- 间接通信方式：通过“信箱”间接地通信。因此又称“信箱通信方式

###### 管道通信（队列）

进程1->管道->进程2  要么进程1写数据到管道，进程2从管道读数据；要么进程2写数据到管道，进程1从管道读数据。是单向的。

“管道”是一个特殊的共享文件，又名pipe文件。其实就是在内存中开辟一个大小固定的内存缓冲区。管道是一个循环队列，读写是先进先出的。

1. 管道只能采用半双工通信，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道。
2. 各进程要互斥地访问管道(由操作系统实现)
3. 管道写满时，写进程将阻塞，直到读进程将管道中的数据取走，即可唤醒写进程。
4. 当管道读空时，读进程将阻塞，直到写进程往管道中写入数据，即可唤醒读进程。
5. 管道中的数据一旦被读出，就彻底消失。因此当多个进程读同一个管道时，可能会错乱。对此，通常有两种解决方案。（1）一个管道允许多个写进程，一个读进程;（以这个为准）（2）允许有多个写进程，多个读进程，但系统会让各个读进程轮流从管道中读数据。

![image-20241209164345186](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241209164345186.png)

写进程往管道写数据，即便管道没被写满，只要管道没空，读进程就可以从管道读数据；

读进程从管道读数据，即便管道没被读空，只要管道没满，写进程就可以往管道写数据。

#### 线程

进程是程序的一次执行。但这些功能显然不可能是由一个程序顺序处理就能实现的。

有的进程可能需要“同时”做很多事，而传统的进程只能串行地执行一系列程序。为此，引入了“线程”，来增加并发度。

进程1：线程1-QQ视频聊天处理程序、线程2-QQ传送文件处理程序。

进程2：线程1-QQ音乐处理程序。

并发执行

传统的进程是程序执行流的最小单位，引入线程后，线程成为了程序执行流的最小单位。

可以把线程理解为“轻量级进程”线程是一个基本的CPU执行单元，也是程序执行流的最小单位。

引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务 (如 QQ视频、文字聊天、传文件)
引入线程后，进程只作为除CPU之外的系统资源的分配单元(如打印机、内存地址空间等都是分配给进程的)。

######  引入线程机制后，有什么变化?




| 资源分配、调度                                             | 并发性                                     | 系统开销                                                     |
| ---------------------------------------------------------- | ------------------------------------------ | ------------------------------------------------------------ |
| 传统进程机制中，进程是资源分配、调度的基本单位             | 传统进程机制中，只能进程间并发             | 传统的进程间并发，需要切换进程的运行环境，系统开销很大       |
| 引入线程后，进程是资源分配的基本单位，线程是调度的基本单位 | 引入线程后，各线程间也能并发，提升了并发度 | 线程间并发，如果是同一进程内的线程切换，则不需要切换进程环境，系统开销小 |
|                                                            |                                            | 引入线程后，并发所带来的系统开销减小                         |

类比:
引入线程后，并发所带来的系统开销减小
去图书馆看书

切换进程运行环境:有一个不认识的人要用桌子，你需要你的书收走，他把自己的书放到桌上

同一进程内的线程切换=你的舍友要用这张书桌，可以不把桌子上的书收走

###### 线程的属性

- 线程是处理机调度的单位
- 多CPU计算机中，各个线程可占用不同的CPU
- 每个线程都有一个线程ID、线程控制块(TCB)-PCB
- 线程也有就绪、阻塞、运行三种基本状态
- 线程几乎不拥有系统资源（这分配给进程）
- 同一进程的不同线程间共享进程的资源
- 由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预
- 同一进程中的线程切换，不会引起进程切换
- 不同进程中的线程切换，会引起进程切换
- 切换同进程内的线程，系统开销很小
- 切换进程，系统开销较大
  

#### 线程的实现方式

###### 用户级线程(User-LevelThread,ULT)


历史背景:早期的操作系统(如:早期Unix)只支持进程，不支持线程。当时的“线程”是由线程库实现的。

```c
//QQ进程
int main(){
	int i =0;
	while(true){
          if(i==0){处理视频聊天的代码;}
          if(i==1){处理文字聊天的代码;}
          if(i==2){处理文件传输的代码;}
          i=(i+1)%3; //i的值为 0,1,2,0,1,2...
     }
}
```

从代码的角度看，线程其实就是一段代码逻辑。上述三段代码逻辑上可以看作三个“线程”。while 循环就是一个最弱智的“线程库”，线程库完成了对线程的管理工作(如调度)。

很多编程语言提供了强大的线程库，可以实现线程的创建、销毁、调度等功能。

问题：

1. 线程的管理工作由谁来完成?
2. 线程切换是否需要CPU变态?
3. 操作系统是否能意识到内核级线程的存在?
4. 这种线程的实现方式有什么优点和缺点?

答案：

1. 用户级线程由应用程序通过线程库实现，所有的线程管理工作都由应用程序负责(包括线程切换)
2. 用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。
3. 在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。“用户级线程”就是“从用户视角看能看到的线程”
4. 优缺点：优点:用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高。缺点:当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。

###### 内核级线程(Kernel-LevelThread,KLT,又称“内核支持的线程”)


由操作系统支持的线程。

1. 内核级线程的管理工作由操作系统内核完成。
2. 线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。
3. 操作系统会为每个内核级线程建立相应的TCB(Thread Control Block，线程控制块)，通过TCB对线程进行管理。“内核级线程”就是“从操作系统内核视角看能看到的线程
4. 优缺点：
   优点:当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。缺点:一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。

###### 多线程模型

在支持内核级线程的系统中，根据用户级线程和内核级线程的映射关系，可以划分为几种多线程模型。

一对一模型:一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同同数量的内核级线程。
优点:当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。
缺点:一个用户进程会占用多个内核级线程线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。



多对一模型:多个用户级线程映射到一个内核级线程。且一个进程只被分配一个内核级线程。
优点:用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高
缺点:当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行
重点重点重点:操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位。



多对多模型:n用户及线程映射到m个内核级线程(n>=m)。每个用户进程对应m个内核级线程。克服了多对一模型并发度不高的缺点(一个阻塞全体阻塞)，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。可以这么理解:用户级线程是“代码逻辑”的载体内核级线程是“运行机会”的载体。
内核级线程才是处理机分配的单位。例如:多核CPU环境下，左边这个进程最多能被分配两个核。

![image-20241210163947314](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241210163947314.png)

#### 线程的状态与转换

![image-20241210164341776](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241210164341776.png)

#### 处理机的调度

- 基本概念
- 三个层次：高级调度(作业调度)、中级调度(内存调度)、低级调度(进程调度)
- 三层调度的联系、对比
- 补充知识：进程的“挂起态"、七状态模型

当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序，这就是“调度”研究的问题。

###### 高级调度(作业调度)

作业:一个具体的任务
用户向系统提交一个作业=用户让操作系统启动一个程序(来处理一个具体的任务)

简化理解:好几个程序需要启动，到底先启动哪个
高级调度(作业调度)。按一定的原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程。每个作业只调入一次，调出一次。作业调入时会建立PCB，调出时才撤销PCB。

###### 低级调度(进程调度)

低级调度(进程调度/处理机调度)--按照某种策略从就绪队列中选取一个进程，将处理机分配给它。

进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。
进程调度的频率很高，一般几十毫秒一次。

###### 中级调度

内存不够时，可将某些进程的数据调出外存。等内存空闲或者进程需要运行时再重新调入内存。

暂时调到外存等待的进程状态为挂起状态。被挂起的进程PCB会被组织成挂起队列中级调度(内存调度)--按照某种策略决定将哪个处于挂起状态的进程重新调入内存。

###### 进程的挂起态与七状态模型

暂时调到外存等待的进程状态为挂起状态(挂起态，suspend)。

挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态

五状态模型 →七状态模型

![image-20241211094148052](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241211094148052.png)

注意“挂起”和“阻塞”的区别，两种状态都是暂时不能获得CPU的服务，但挂起态是将进程映像调到外存去了，而阻塞态下进程映像还在内存中。有的操作系统会把就绪挂起、阻塞挂起分为两个挂起队列，甚至会根据阻塞原因不同再把阻塞挂起进程进一步细分为多个队列。

###### 三层调度的联系、对比




|                  | 高级调度(作业调度)                                           | 中级调度(内存调度)                                       | 低级调度(进程调度)                                   |
| ---------------- | ------------------------------------------------------------ | -------------------------------------------------------- | ---------------------------------------------------- |
| 要做什么         | 按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程 | 按照某种规则，从挂起队列中选择合适的进程将其数据调回内存 | 按照某种规则，从就绪队列中选择一个进程为其分配处理机 |
| 调度发生在       | 外存→内存(面向作业)                                          | 外存→内存(面向进程)                                      | 内存→CPU                                             |
| 发生频率         | 最低                                                         | 中等                                                     | 最高                                                 |
| 对进程状态的影响 | 无→创建态→就绪态                                             | 挂起态→就绪态(阻塞挂起→阻塞态)                           | 就绪态→运行态                                        |

![image-20241211094727660](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241211094727660.png)



###### 进程调度的时机

需要进行进程调度与切换的情况

- 当前运行的进程主动放弃处理机：进程正常终止、运行过程中发生异常而终止、进程主动请求阻塞(如等待I/0)
- 当前运行的进程被动放弃处理机：分给进程的时间片用完、有更紧急的事需要处理(如I/O中断)、有更高优先级的进程进入就绪队列

不能进行进程调度与切换的情况：

1. 在处理中断的过程中。中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换。

2. 进程在操作系统内核程序临界区中。
3. 在原子操作过程中(原语)。原子操作不可中断，要一气呵成(如之前讲过的修改PCB中进程状态标志，并把PCB放到相应队列)









