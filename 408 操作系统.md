#### 一天看两个小时，两周看完!!!!

12.8  1.1.1-1.4.2 共116分钟



#### 操作系统的概念和定义

操作系统(Operating system，OS)是指

- 控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配;（操作系统是系统资源的管理者）
- 以提供给用户和其他软件方便的接口和环境;（向上层提供方便易用的服务）
- 它是计算机系统中最基本的系统软件。（是最接近硬件的一层软件）

提供的功能

- 处理机管理
- 存储器管理
- 文件管理
- 设备管理

向上层提供方便易用的服务：

GUI:图形化用户接口(Graphical User Interface)：用户可以使用形象的图形界面进行操作，而不再需要记忆复杂的命令、参数。

联机命令接口（交互式命令接口）：用户说一句，系统跟着做一句（AIT+R打开命令行窗口，输入一条命令，返回一个结果）

脱机命令接口（批处理命令接口）：用户说一堆，系统跟着做一堆，使用windows系统的搜索功能，搜索C盘中的*.bat文件，用记事本任意打开一个

程序接口:可以在程序中进行系统调用（广义指令）来使用程序接口。普通用户不能直接使用程序接口，只能通过程序代码间接使用。（如:写C语言“Hello world”程序时，在printf 函数的底层就使用到了操作系统提供的显式相关的“系统调用”）

![image-20241208155106672](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241208155106672.png)

![image-20241208155250292](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241208155250292.png)

计算机系统实现对硬件机器的拓展：

类比汽车:发动机--只会转;轮胎--只会滚;
在原始的硬件机器上覆盖一层传动系统--让发动机带着轮子转--使原始的硬件机器得到拓展

操作系统对硬件机器的拓展:将CPU、内存、磁盘、显示器、键盘等硬件合理地组织起来，让各种硬件能够相互协调配合，实现更多更复杂的功能，

#### 操作系统的特征

###### 并发

并发:指两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的。

并行:指两个或多个事件在同一时刻同时发生。

操作系统就是伴随着“多道程序技术”而出现的。因此，操作系统和程序并发是一起诞生的。

注意(重要考点):

单核CPU同一时刻只能执行一个程序，各个程序只能并发地执行多核CPU同一时刻可以同时执行多个程序，多个程序可以并行地执行。
比如Intel的第八代i 3处理器就是4核CPU，意味着可以并行地执行4个程序。

###### 共享

共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。

分为：

- 互斥共享方式：系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源
- 同时共享方式：系统中的某些资源，允许一个时间段内由多个进程“同时”对它们进行访问

所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问的(即分时共享)

生活实例:

互斥共享方式:使用QQ和微信视频。同一时间段内摄像头只能分配给其中一个进程。

同时共享方式:使用QQ发送文件A，同时使用微信发送文件B。宏观上看，两边都在同时读取并发送文件，说明两个进程都在访问硬盘资源，从中读取数据。微观上看，两个进程是交替着访问硬盘的。

###### 并发于共享的关系

使用QQ发送文件A，同时使用微信发送文件B。

- 两个进程正在并发执行(并发性)  如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义

- 需要共享地访问硬盘资源(共享性)  如果失去共享性，则QQ和微信不能同时访问硬盘资源，就无法实现同时发送文件，也就无法并发

  

###### 虚拟

 虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体(前者)是实际存在的，而逻辑上对应物(后者)是用户感受到的。

Yo~用一个例子来理解背景知识:一个程序需要放入内存并给它分配CPU才能执行

GTA5需要4GB的运行内存，QQ需要256MB的内存，迅雷需要256MB的内存，网易云音乐需要256MB的内存.…

我的电脑:4GB内存

问题:这些程序同时运行需要的内存远大于4GB，那么为什么它们还可以在我的电脑上同时运行呢?
这是虚拟存储器技术（虚拟技术中的“空分复用技术”），实际只有4GB的内存，在用户看来似乎远远大于4GB

虚拟技术的分类：

- 空分复用技术(如虚拟存储器技术)
- 时分复用技术(如虚拟处理器)

显然，如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了。因此，没有并发性，就谈不上虚拟性。

###### 异步

异步是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限（打印机、摄像头），进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。

一号的指令1:老渣陪我吃饭  一号的指令2:老渣把心给我  第一道程序
二号的指令1:老渣把心给我  二号的指令2:老渣陪我吃饭  第二道程序

如果失去了并发性，即系统只能串行地运行各个程序，那么每个程序的执行会一贯到底。只有系统拥有并发性，才有可能导致异步性。

![image-20241208161307865](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241208161307865.png)

#### 操作系统的发展与分类
|        | 手工操作阶段                                 | 批处理阶段（单道批处理系统、）                               | 分时操作系统                                                 | 实时操作系统                                                 | 网络操作系统 | 分布式操作系统 | 个人计算机操作系统 |
| ------ | -------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------ | -------------- | ------------------ |
| 优缺点 | 用户独占全机、人机速度矛盾导致资源利用率极低 | 主要优点:缓解了一定程度的人机速度矛盾，资源利用率有所提升。<br/>主要缺点:内存中仅能有一道程序运行，只有该程序运行结束之后才能调入下一道程序。CPU有大量的时间是在空闲等待I/0完成。资源利用率依然很低。 | 主要优点:用户请求可以被即时响应，解决了人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。<br/>主要缺点:不能优先处理一些紧急任外。操作系统对各个用户/作业都是完全公平的，循环地为每个用户作业服务一个时间片，不区分任务的紧急性。 | 主要优点:能够优先响应一些紧急任务，某些紧急任务不需时间片排队。 |              |                |                    |
|        |                                              | 主要优点:多道程序并发执行，共享计算机资源。资源利用率大幅提升，CPU和其他资源更能保持“忙碌”状态，系统吞吐量增大。<br/>主要缺点:用户响应时间长，没有人机交互功能(用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行。eg:无法调试程序/无法在程序运行过程中输入一些参数) |                                                              |                                                              |              |                |                    |

手工阶段：程序员将数据以打孔的方式放入纸带机中（慢），计算机中读入数据（慢），计算机进行计算（快），计算机在纸带机上打孔（慢），程序员从纸上读取数据（慢）。

单道批：引入脱机输入/输出技术(用外围机+磁带完成，通过外围机把程序提前存到磁带里)，并由监督程序（操作系统的雏形）负责控制作业的输入、输出。

多道批：单道批的扩展，计算第二个程序时，输入第三个程序，输出第一个程序。（操作系统正式诞生，用于支持多道程序并发运行）

分时操作系统:计算机以时间片为单位轮流为各个用户/作业服务，各个用户可通过终端与计算机进行交互。

实时操作系统:

在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完事件。实时操作系统的主要特点是及时性和可靠性。

分为：

- 硬实时系统：必须在绝对严格的规定时间内完成处理，如:导弹控制系统自动驾驶系统
- 软实时系统：能接受偶尔违反时间规定，如:12306火车订票系统（余票数量的更新时间可接受几秒钟的延迟）

网络操作系统:是伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机地结合起来，实现数据传送等功能，实现网络中各种资源的共享(如文件共享)和各台计算机之间的通信。(如:Windows NT 就是一种典型的网络操作系统，网站服务器就可以使用)

分布式操作系统:主要特点是分布性和并行性。系统中的各台计算机地位相同，任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务。

个人计算机操作系统:如WindowsXP、Macos，方便个人使用。

![image-20241208163521319](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241208163521319.png)

#### 操作系统的运行机制

“指令”就是处理器(CPU)能识别、执行的最基本命令

注:很多人习惯把 Linux、Windows、MacOs的“小黑框”中使用的命令也称为“指令”，其实这是“交互式命令接口”，注意与本节的“指令”区别开。本节中的“指令”指二进制机器指令。

###### 内核程序 v.s. 应用程序

我们普通程序员写的程序就是应用程序

微软、苹果有一帮人负责实现操作系统，他们写的是“内核程序”由很多内核程序组成了“操作系统内核”，或简称“内核(Kernel)

内核是操作系统最重要最核心的部分，也是最接近硬件的部分甚至可以说，一个操作系统只要有内核就够了(eg:Docker->仅需Lnux内核)

操作系统的功能未必都在内核中，如图形化用户界面GUI

操作系统内核作为“管理者”，有时会让CPU执行一些“特权指令”，如:内存清零指令。这些指令影响重大，只允许“管理者”--即操作系统内核来使用。

应用程序只能使用“非特权指令”，如:加法指令、减法指令等。

在CPU设计和生产的时候就划分了特权指令和非特权指令，因此CPU执行一条指令前就能判断出其类型。

###### 内核态 v.s.用户态

CPU 能判断出指令类型，但是它怎么区分此时正在运行的是内核程序or 应用程序?

CPU有两种状态，“内核态”和“用户态

处于内核态时，说明此时正在运行的是内核程序，此时可以执行

特权指令处于用户态时，说明此时正在运行的是应用程序，此时只能执行非特权指令

拓展:CPU中有一个寄存器叫程序状态字寄存器(PSW)，其中有个二进制位，1表示“内核态”，0表示“用户态。

###### 内核态与用户态的切换

1. 刚开机时，CPU为“内核态”，操作系统内核程序先上CPU运行（开机时，初始化操作系统）
2. 开机完成后，用户可以启动某个应用程序
3. 操作系统内核程序在合适的时候主动让出CPU，让该应用程序上CPU运行（操作系统内核在让出CPU之前，会用一条特权指令把 PSW 的标志位设置为“用户态”）
4. 应用程序运行在“用户态”
5. 此时，一位猥琐黑客在应用程序中植入了一条特权指令，企图破坏系统CPU发现接下来要执行的这条指令是特权指令，但是自己又处于“用户态“
6. 这个非法事件会引发一个中断信号（CPU检测到中断信号后，会立即变为“核心态”，并停止运行当前的应用程序，转而运行处理中断信号的内核程序）
7. “中断”使操作系统再次夺回CPU的控制权
8. 操作系统会对引发中断的事件进行处理，处理完了再把CPU使用权交给别的应用程序

![image-20241208170835600](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241208170835600.png)

#### 中断和异常

###### 中断的作用

CPU 上会运行两种程序，一种是操作系统内核程序（是整个系统的管理者），一种是应用程序。

“中断”是让操作系统内核夺回CPU使用权的唯一途径，如果没有“中断”机制，那么一旦应用程序上CPU运行，CPU就会一直运行这个应用程序。

内核态→用户态:执行一条特权指令--修改PSW的标志位为“用户态”，这个动作意味着操作系统将主动让出CPU使用权。

用户态→内核态:由“中断”引发，硬件自动完成变态过程，触发中断信号意味着操作系统将强行夺回CPU的使用权。

###### 中断的类型

内中断：与当前执行的指令有关，中断信号来源于CPU内部。
外中断：与当前执行的指令无关，中断信号来源于CPU外部。

###### 内中断

- 例子1:试图在用户态下执行特权指令
- 例子2:执行除法指令时发现除数为0 （若当前执行的指令是非法的，则
  会引发一个中断信号）

- 例子3:有时候应用程序想请求操作系统内核的服务，此时会执行一条特殊的指令--陷入指令（非特权指令），该指令会引发一个内部中断信号（执行“陷入指令”，意味着应用程序主动地将CPU控制权还给操作系统内核。“系统调用”就是通过陷入指令完成的）

###### 外中断

- 例子1:时钟中断--由时钟部件发来的中断信号（程序并发执行：时钟部件每隔一个时间片，会给CPU发送一个时钟中断信号） （执行程序1的指令1，到时间了收到中断信号，操作系统转换为内核态并停止执行应用程序并处理时钟中断信号，即分析出程序1的指令1到时，此时结束，转换为用户态，执行程序2的指令1）
- 例子2:I/0中断--由输入/输出设备发来的中断信号，当输入输出任务完成时，向CPU发送中断信号

![image-20241208172527188](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241208172527188.png)

###### 中断机制的基本原理

不同的中断信号，需要用不同的中断处理程序来处理。当CPU检测到中断信号后，会根据中断信号的类型去查询“中断向量表”，以此来找到相应的中断处理程序在内存中的存放位置。

显然，中断处理程序一定是内核程序，需要运行在“内核态”。

![image-20241208172752393](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241208172752393.png)

#### 系统调用

操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务。主要包括命令接口和程序接口。其中，程序接口由一组系统调用组成。

“系统调用”是操作系统提供给应用程序(程序员/编程人员)使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以通过系统调用来请求获得操作系统内核的服务。

| 普通应用程序 | 可直接进行系统调用，也可使用库函数，有的库函数涉及系统调用，有的不涉及 |
| ------------ | ------------------------------------------------------------ |
| 编程语言     | 向上提供库函数。有时会将系统调用封装成库函数，以隐藏系统调用的一些细节，使程序员编程更加方便。 |
| 操作系统     | 向上提供系统调用，使得上层程序能请求内核的服务               |
| 裸机         |                                                              |

不涉及系统调用的库函数:如的“取绝对值”的函数

涉及系统调用的库函数:如“创建一个新文件”的函数

###### 小例子:为什么系统调用是必须的?

生活场景:去学校打印店打印论文，你按下了WPS的“打印”选项，打印机开始工作。你的论文打印到一半时，另一位同学按下了Word 的“打印”按钮，开始打印他自己的论文。
思考:如果两个进程可以随意地、并发地共享打印机资源，会发生什么情况?
两个进程并发运行，打印机设备交替地收到WPS和 Word 两个进程发来的打印请求，结果两篇论文的内容混杂在一起了…

解决方法:由操作系统内核对共享资源进行统一的管理，并向上提供“系统调用”，用户进程想要使用打印机这种共享资源，只能通过系统调用向操作系统内核发出请求。内核会对各个请求进行协调处理。

###### 系统调用的分类

按功能分：

设备管理：完成设备的 请求/释放/启动 等功能
文件管理：完成文件的 读/写/创建/删除 等功能
进程控制：完成进程的 创建/撤销/阻塞/唤醒 等功能
进程通信：完成进程之间的 消息传递/信号传递 等功能
内存管理：完成内存的 分配/回收 等功能

应用程序通过系统调用请求操作系统的服务。而系统中的各种共享资源都由操作系统内核统一掌管，因此凡是与共享资源有关的操作(如存储分配、I/0操作、文件管理等)，都必须通过系统调用的方式向操作系统内核提出服务请求，由操作系统内核代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。

###### 系统调用的过程

应用程序发  传参指令1（指明系统调用类型，如fork）  到  CPU的寄存器

应用程序发  陷入指令  到  CPU的寄存器  （该中断由陷入指令引发，因此转入相应的中断处理程序--即 系统调用的入口程序（内核态））

系统调用入口程序 根据寄存器中的参数判断用户需要fork系统调用服务

fork 系统调用的处理程序发指令到CPU中

结束完成后继续执行应用程序的下一条指令 

![image-20241208175236556](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241208175236556.png)

![image-20241208175346561](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241208175346561.png)

#### 操作系统的体系结构

内核怎么设计？

![image-20241208175530574](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241208175530574.png)

操作系统内核分为：

- 时钟管理：实现计时功能
- 中断处理：负责实现中断机制
- 原语：是一种特殊的程序、处于操作系统最底层，是最接近硬件的部分、这种程序的运行具有原子性其运行只能一气呵成，不可中断、运行时间较短、调用频繁
- 对系统资源进行管理的功能：进程管理、存储器管理、设备管理

时钟管理、中断处理、原语是与硬件关联较紧密的模块
对系统资源进行管理的功能这些管理工作更多的是对数据结构的操作，不
会直接涉及硬件。

###### 大内核（又名:宏内核/单内核)）

全部包含

###### 微内核

只包含时钟管理、中断处理、原语。故对系统资源进行管理的功能：进程管理、存储器管理、设备管理这些要使用时，必须转换为用户态才能使用。（操作系统状态的转换的过程是有成本的，要消耗不少时间，频繁地变态会降低系统性能）


![image-20241208180438335](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241208180438335.png)

|                 | 特性思想                                                     |                             优点                             |                             缺点                             |
| --------------- | :----------------------------------------------------------- | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 分层结构        | 内核分多层，每层可单向调用（相邻）更低一层提供的接口         | 1.便于调试和验证，自底向上逐层调试验证<br/>2.易扩充和易维护，各层之间调用接口清晰固定 | 1.仅可调用相邻低层，难以合理定义各层的边界<br/>2.效率低，不可跨层调用，系统调用执行时间长 |
| 模块化          | 将内核划分为多个模块，各模块之间相互协作。内核 =主模块+可加载内核模块  主模块:只负责核心功能，如进程调度、内存管理  <br/>可加载内核模块:可以动态加载新模块到内核而无需重新编译整个内核（驱动） | 1.模块间逻辑清晰易于维护，确定模块间接口后即可多模块同时开发<br/>2.支持动态加载新的内核模块(如:安装设备驱动程序、安装新的文件系统模块到内核)，增强OS适应性<br/>3.任何模块都可以直接调用其他模块，无需采用消息传递进行通信，效率高 | 1.模块间的接口定义未必合理、实用<br/>2.模块间相互依赖，更难调试和验证 |
| 宏内核(大内核)  | 所有的系统功能都放在内核里(大内核结构的OS通常也采用了"模块化"的设计思想) |          性能高，内核内部各种功能都可以直接相互调用          | 1.内核庞大功能复杂，难以维护<br/>2.大内核中某个功能模块出错，就可能导致整个系统崩溃 |
| 微内核          | 只把中断、原语、进程通信等最核心的功能放入内核。进程管理、文件管理、设备管理等功能以用户进程的形式运行在用户态 | 1.内核小功能少、易于维护，内核可靠性高<br/>2.内核外的某个功能模块出错不会导致整个系统崩溃 | 1.性能低，需要频繁的切换 用户态/核心态。<br/>2.用户态下的各功能模块不可以直接相互调用，只能通过内核的”消息传递“来间接通信（进程管理、存储管理、设备管理与时钟管理、中断处理、原语之间的联系） |
| 外核(exokernel) | 内核负责进程调度、进程通信等功能，外核负责为用户进程分配未经抽象的硬件资源，且由外核负责保证资源使用安全 | 1.外核可直接给用户进程分配“不虚拟、不抽象”的硬件资源，使用户进程可以更灵活的使用硬件资源<br/>2.减少了虚拟硬件资源的”映射层”，提升效率 |         1.降低了系统的一致性<br/>2.使系统变得更复杂          |

###### 分层结构

![image-20241208181501798](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241208181501798.png)

1.自下向上逐层调试

2.便于新加：向上提供的不变就可

1.各层的功能会相同，并且低层会用到相邻的高层的功能，

2.有时高层要用到最底层的，但是必须逐层

###### 模块化

1.该模块有3个接口，只要先确定了要连接的模块的接口相同，就可以专心开发自己的模块了。

2.新的模块直接加入就可

3.直接调用函数就能使用其他模块了

1.因为相互调用的次数多，所以接口的定义可能会不合理

2.不知道是自身有问题还是调用的模块有问题

###### 外核（虚拟内存）

外核负责为用户进程分配未经抽象的硬件资源。